# Написание историй на ink

## Введение

**ink** это скриптовый язык, построенный вокруг идеи разметки чистого текста на потоки с тем, чтобы создавать интерактивные скрипты.

На самом базовом уровне он может быть использован для написания историй по типу "выбери себе приключение" или разветвлённого дерева диалогов. Но его реальная сила - в написании диалогов с массой вариантов выбора и большим количеством рекомбинаций потоков текста.

**ink** предлагает несколько функций, позволяющих нетехническим писателям часто разветвлять свою историю и играть с последствиями этих разветвлений, большими и маленькими, и всё это без особых хлопот.

Скрипт создан с целью быть ясным и логически упорядоченным, так чтобы разветвлённый диалог можно было проверить "глазами". Порядок ветвлений описывается в повествовательно манере там, где только это возможно.

Также **ink** задумывался с учётом переписывания историй, так что правка должна быть простой и быстрой.

# Часть 1: Основы

## 1) Содержимое

### Простейший ink-скрипт

Самый базовый ink-скрипт - это просто текст в файле с расширением .ink:

	Привет, мир!

Если запустить его, он выведет своё содержимое, а затем остановится.

Текст, разбитый на строки, создаёт новые параграфы. Такой скрипт:

	Привет, мир!
	Привет?
	Привет, ты там?

выведет результат, выглядящий точно так же.


### Комментарии

По умолчанию, весь текст в вашем файле будет выведен в результат, если только он не размечен специальным образом.

Простейшей разметкой являются комментарии. **ink** поддерживает два типа комментариев. Первый тип используется для того, кто читает код, компилятор игнорирует такие комментарии:

	"Что вы думаете об этом?", спросила она.

	// Нечто непечатное...

	"Я никак не могу это прокомментировать",  ответил я.

	/*
		... или неограниченный кусок текста
	*/

И существует другой тип комментариев, служащий для того, чтобы напомнить автору что ему нужно сделать. Компилятор выводит такие комментарии в процессе компиляции:

	TODO: Эту часть следует переписать!

### Теги

Текстовое содержимое игры появится на выходе "как есть", когда движок будет запущен. Однако, иногда бывает полезно дополнить строку содержимого дополнительной информацией о том, чтобы сказать игре, что делать с этим содержимым.

**ink** предоставляет простую систему a simple system пометки строк содержимого с помощью хэштегов.

	=== содержимое
		Строка нормального текста из игры. # покрасить в синий

Эти хэштеги не попадают в основной поток текста, но могут быть прочитаны игрой и использованы так, как вы желаете. См.  [RunningYourInk](https://github.com/inkle/ink/blob/master/Documentation/RunningYourInk.md#marking-up-your-ink-content-with-tags) для более подробной информации.


## 2) Варианты выбора

Игрок взаимодействует с игрой посредством выбора из вариантов. Текстовый вариант выбора обозначается символом `*`.

Если никаких других инструкций не указано, когда игрок делает выбор, его текст попадает в основной текст игры.

	Привет, мир.
	*	И тебе привет!
		Рад тебя видеть!

Результатом будет следующая игра:

	Привет, мир.
	1: И тебе привет!

	> 1
	И тебе привет!
	Рад тебя видеть!

По умолчанию, текст выбора появляется снова, в выходном потоке текста.

### Подавление текста выбора

Некоторые игры разделяют текст варианта и результат, получаемый при его выборе. В **ink** если текст выбора записан в квадратных скобках, то он не будет напечатан в ответе.

	Привет, мир!
	*	[И тебе привет!]
		Приятно слышать!

выводит

	Привет, мир!
	1: И тебе привет!

	> 1
	Приятно слышать!

#### Дополнительно: текст выбора и выводимый текст можно смешивать

На самом деле, квадратные скобки разделяют содержимое варианта выбора. То, что до них выводится и в тексте выбора, и при ответе; то, что внутри - только в тексте выбора; и то, что после - только в тексте ответа. В сущности, они предоставляют альтернативные способы описания строки текста.

	Привет, мир!
	*	И тебе [привет!] тоже привет, дружище!
		Приятно слышать!

выводит:

	Привет, мир!
	1: И тебе привет!
	> 1
	И тебе тоже привет, дружище!
	Приятно слышать!

Это особенно удобно при написании вариантов в диалогах:

	"В чём дело?" - спросил мой господин.
	*	"Я несколько устал[."]", повторил я.
		"В самом деле" - сказал он. "Как разрушительно."

выводит:

	"В чём дело?" - спросил мой господин.
	1. "Я несколько устал."
	> 1
	"Я несколько устал", повторил я.
	"В самом деле" - сказал он. "Как разрушительно."

### Множественный выбор

Чтобы сделать выбор действительно выбором, необходимо предоставить несколько вариантов для выбора. Мы можем сделать это попросту добавив их в список:

	"В чём дело?" - спросил мой господин.
	*	"Я несколько устал[."]", повторил я.
		"В самом деле" - сказал он. "Как разрушительно."
	*	"Ни в чём, месье!"[] - ответил я.
		"Что ж, очень хорошо."
	*	"Я говорю, это путешествие отвратительно[."] и я не хочу больше в нём участвовать."
		"А", ответил он без раздражения. "Я вижу, ты раздосадован. Завтра всё наладится."

На выходе получится следующая игра:

	"В чём дело?" - спросил мой господин.

	1: "Я несколько устал."
	2: "Ни в чём, месье!"
	3: "Я говорю, это путешествие отвратительно."

	> 3
	"Я говорю, это путешествие отвратительно и я не хочу больше в нём участвовать."
	"А", ответил он без раздражения. "Я вижу, ты раздосадован. Завтра всё наладится."

Синтаксис в примере выше достаточен, чтобы написать единичный набор вариантов выбора. В настоящей игре нам нужно перемещаться с одной точки на другую, основываясь на выборе игрока. Чтобы достичь этого, необходимо добавить ещё немного структуры.

## 3) Узлы

### Части содержимого называются узлами

Чтобы позволить игре разветвляться, нам нужно пометить секции содержимого, дав им названия (как в старых книгах-играх с их "Параграф 18" и тому подобное).

Эти секции называются "узлами" и они являются фундаментальным элементом структуры в **ink**.

### Написание узла

Начало узла обозначается двумя или более знаками равенства, как показано дальше:

	=== верхний_узел ===

(Знаки "равно" в конце необязательны; и название должно быть единым словом без пробелов.)

Начало узла - это заголовок, дальнейший текст попадает внутрь этого узла.

	=== назад_в_лондон ===

	Мы прибыли в Лондон ровно в 9:45 вечера.

#### Дополнительно: более узловатый "привет мир"

Когда вы начинаете писать файл ink, содержимое вне узлов будет запущено автоматически. Но не узлы. Так что если вы начинаете использовать узлы для разметки вашего текста, вам следует объяснить игре, куда идти. Мы сделаем это с помощью стрелки перехода `->`, о которой подробнее поговорим в следующем разделе.

Простейший скрипт с узлами выглядит так:

	-> верхний_узел

	=== верхний_узел ===
	Привет, мир!

Однако, **ink** не любит неоконченные дела и выдаёт предупреждение при компиляции и/или во время запуска, когда думает, что это произошло. Скрипт выше выдаст вот такое при компиляции:

	WARNING: Apparent loose end exists where the flow runs out. Do you need a '-> END' statement, choice or divert? on line 3 of tests/test.ink

	ВНИМАНИЕ: Обнаружен незакрытый финал, поток просто прерывается. Возможно нужен '-> END', выбор или переход? на строке 3 в файле tests/test.ink

и вот такое при запуске:

	Runtime error in tests/test.ink line 3: ran out of content. Do you need a '-> DONE' or '-> END'?

	Ошибка выполнения tests/test.ink line 3: закончилось содержимое. Возможно, нужен '-> DONE' или '-> END'?

Следующий скрипт компилируется и запускается без ошибок:

	=== верхний_узел ===
	Привет, мир!
	-> END

`-> END` является маркером и для писателя, и для компилятора; он означает "течение истории должно теперь прекратиться".

## 4) Переходы

### Узлы направляют в другие узлы

Вы можете приказать истории двигаться от узла к узлу, используя `->`, "стрелку перехода". Переход происходит немедленно, безо всякого вмешательства игрока.

	=== назад_в_лондон ===

	Мы прибыли в Лондон ровно в 9:45 вечера.
	-> спешить_домой

	=== спешить_домой ===
	Мы поспешили домой на Савил-Роу так быстро, как только могли.

#### Перенаправления невидимы

Переходы специально сделаны бесшовными и могут происходить даже посреди предложения:

	=== спешить_домой ===
	WМы поспешили домой на Савил-Роу так быстро -> как_только_могли

	=== как_только_могли ===
	, как только могли.

выдаст тот же текст, что и выше:

	Мы поспешили домой на Савил-Роу так быстро, как только могли.

#### Клей

По умолчанию, **ink** вставляет разрыв строки перед каждой новой строкой текста. В некоторых случаях, однако, необходимо настоять, чтобы в тексте не было разрывов строк, и это можно сделать с помощью `<>`, или "клея".

	=== спешить_домой ===
	Мы поспешили домой <>
	-> на_савил_роу

	=== на_савил_роу ===
	на Савил-Роу
	-> быстро_как_только_могли

	=== быстро_как_только_могли ===
	<> так быстро, как только могли.

тоже выводит:

	Мы поспешили домой на Савил-Роу так быстро, как только могли.

Вы не можете намазать слишком много клея: несколько "клеев", идущих подряд, не имеют дополнительного эффекта. (Также, нет способа "нейтрализовать" клей; как только строка стала липкой, она прилипнет.)


## 5) Ветвление истории

### Базовое ветвление

Комбинируя узлы, варианты выбора и переходы, мы получим базовую структуру игры типа "выбери себе приключение".

	=== параграф_1 ===
	Ты стоишь перед стеной, окружающей Аналанд, с мечом в руке.
	* [Открыть ворота] -> параграф_2
	* [Разбить ворота] -> параграф_3
	* [Развернуться и пойти домой] -> параграф_4

	=== параграф_2 ===
	Ты открываешь ворота и шагаешь по дороге.

	...

### Ветвление и соединение

Используя переходы, писатель может разветвлять повествование и соединять его обратно, не показывая при этом игроку, что оно было заново слито в единый поток.

	=== назад_в_лондон ===

	Мы прибыли в Лондон ровно в 9:45 вечера.

	*	"Мы не должны проиграть!"[], провозгласил я.
		-> спешить_наружу

	*	"Месье, давайте насладимся этим мгновением!"[], воскликнул я.
		Господин дал мне подзатыльник и выволок меня через дверь наружу.
		-> вытащен_наружу

	*	[Мы поспешили домой] -> спешить_наружу


	=== спешить_наружу ===
	Мы поспешили домой на Савил-Роу
	-> быстро_как_только_могли


	=== вытащен_наружу ===
	Он настоял, чтобы мы поспешили домой на Савил-Роу
	-> быстро_как_только_могли


	=== быстро_как_только_могли ===
	<> так быстро, как только могли.


### Повествование

Узлы и переходы комбинируются, чтобы создать базовое повествование в игре. Это повествование "плоское" - в нём нет "стека вызовов" и из переходов нельзя "вернуться".

В большинстве ink-скриптов история начинается сверху, мечется по всему коду в стиле спагетти и, в конце концов, будем надеяться, достигает `-> END`.

Очень свободная структура означает, что писатель может легко взяться за дело, разветвляя и объединяя повествование не волнуясь о структуре, которую создаёт прямо на ходу. Нет каких-то шаблонных заготовок для создания новых ветвей или переходов, а также нет необходимости следить за текущим состоянием.

#### Дополнительно: Циклы

Вы безусловно можете использовать переходы для создания зацикленного содержимого, и в **ink** есть несколько функциональных возможностей для их использования, включая такие, которые помогут тексту меняться самостоятельно, а также способы контролировать как часто может быть выбран тот или иной вариант выбора.

Смотрите главы *Меняющийся текст* и *Условные варианты выбора* для более подробной информации.

О, и следующее вполне легально, но не слишком хорошая идея:

	=== кругом ===
	и
	-> кругом

## 6) Включения и стежки

### Узлы можно разделять на более мелкие части

По мере того, как история становится длиннее, её всё труднее сохранять в организованном виде без какой-либо дополнительной структуры.

Узлы могут включать в себя подсекции, которые называются "стежки". Они размечаются с использованием единичного знака равенства.

	=== восточный_экспресс ===
	= в_первом_классе
		...
	= в_третьем_классе
		...
	= в_вагоне_охраны
		...
	= опоздали_на_поезд
		...

Можно, например, использовать узел в качестве сцены, а стежки - для событий на этой сцене.

### У стежков уникальные названия

На стежок можно перейти, используя его "адрес".

	*	[Путешествовать третьим классом]
		-> восточный_экспресс.в_третьем_классе

	*	[Путешествовать в вагоне охраны]
		-> восточный_экспресс.в_вагоне_охраны

### Первый стежок используется по умолчанию

Переход на узел, содержащий стежки, идёт на первый стежок в этом узле. Так:

	*	[Путешествовать первым классом]
		"Первый класс, месье. Где же ещё?"
		-> восточный_экспресс

то же самое, что и:

	*	[Путешествовать первым классом]
		"Первый класс, месье. Где же ещё?"
		-> восточный_экспресс.в_первом_классе

(...если только мы не изменили порядок стежков в узле!)

Вы также можете добавить текст на вершине узла, вне любого из стежков. Однако вам нужно помнить, что потребуется переход - **ink** *не* заходит автоматически в первый стежок после того, как отработал текст в "заголовке".

	=== восточный_экспресс ===

	Мы сели в поезд, но куда?
	*	[Первый класс] -> в_первом_классе
	*	[Второй класс] -> во_втором_классе

	= в_первом_классе
		...
	= во_втором_классе
		...


### Локальные переходы

Внутри узла нет необходимости использовать полный адрес стежка.

	-> восточный_экспресс

	=== восточный_экспресс ===
	= в_первом_классе
		Я устроил господина здесь.
		*	[Перейти в третий класс]
			-> в_третьем_классе

	= в_третьем_классе
		Себя я поместил в третий.

Это означает, что у узлов и стежков не может быть одинаковых имён, но несколько узлов могут содержать стежки с одинаковыми именами. (Так и в Восточном Экспрессе, и на пароходе "Монголия" может быть свой первый класс.)

Компилятор предупредит вас, если используются неоднозначные названия.

### Файлы скриптов можно комбинировать

Вы также можете разделить содержимое игры по нескольким файлам, используя команду включения `INCLUDE`.

	INCLUDE newspaper.ink
	INCLUDE cities/vienna.ink
	INCLUDE journeys/orient_express.ink


Команды `INCLUDE` всегда должны располагаться в начале файла, не внутри узлов.

Не существует правила о том, в каком файле должен быть узел, чтобы на него можно было перейти. (Другими словами, разделение кода игры по файлам не влияет на пространства имён в игре.)

## 5) Меняющиеся варианты выбора

### Вариант может быть выбран лишь единожды

По умолчанию, каждый вариант выбора в игре может быть выбран лишь один раз. Если у вас нет циклов в вашей истории, то вы никогда не заметите этого поведения. Но если циклы присутствуют, вы быстро обнаружите, что варианты выбора исчезают...

	=== найти_помощь ===

		Вы отчаянно ищете дружественное лицо в толпе.
		*	Женщина в шляпе[?] резко отталкивает вас. -> найти_помощь
		*	Мужчина с портфелем[?] выглядит недовольным, когда вы спотыкаетесь о него. -> найти_помощь

приводит к:

	Вы отчаянно ищете дружественное лицо в толпе.

	1: Женщина в шляпе?
	2: Мужчина с портфелем?

	> 1
	Женщина в шляпе резко отталкивает вас.
	Вы отчаянно ищете дружественное лицо в толпе.

	1: Мужчина с портфелем?

	>

... и на следующем витке цикла у вас не останется варианта выбора.

#### Запасной вариант

Приведённый выше пример останавливается там, где показано, потому что следующий выбор заканчивается ошибкой времени выполнения "out of content" ("закончилось содержимое").

	> 1
	Мужчина с портфелем выглядит недовольным, когда вы спотыкаетесь о него.
	Вы отчаянно ищете дружественное лицо в толпе.

	Runtime error in tests/test.ink line 6: ran out of content. Do you need a '-> DONE' or '-> END'?

	Ошибка выполнения tests/test.ink line 6: закончилось содержимое. Возможно, нужен '-> DONE' или '-> END'?

Мы можем решить эту проблему с помощью "запасного варианта". Запасные варианты никогда не показываются игроку, но они "выбираются" игрой тогда, когда никаких других вариантов не осталось.

Запасной вариант - это попросту "вариант баз текста выбора":
A fallback choice is simply a "choice without choice text":

	*	-> варианты_кончились

И, с небольшим издевательством над синтаксисом, мы можем сделать вариант по умолчанию с содержимым, используя "выбери тогда" стрелку:

	* 	->
		Малдер так никогда и не смог объяснить, как он тогда выбрался из горящей машины. -> второй_сезон

#### Пример запасного варианта

Добавим всё это в предыдущий пример и получим:

	=== найти_помощь ===

		Вы отчаянно ищете дружественное лицо в толпе.
		*	Женщина в шляпе[?] резко отталкивает вас. -> найти_помощь
		*	Мужчина с портфелем[?] выглядит недовольным, когда вы спотыкаетесь о него. -> найти_помощь
		*	->
			Но слишком поздно: вы падаете на вокзальную платформу. Это конец.
			-> END

что выдаст:

	Вы отчаянно ищете дружественное лицо в толпе.

	1: Женщина в шляпе?
	2: Мужчина с портфелем?

	> 1
	Женщина в шляпе резко отталкивает вас.
	Вы отчаянно ищете дружественное лицо в толпе.

	1: Мужчина с портфелем?

	> 1
	Мужчина с портфелем выглядит недовольным, когда вы спотыкаетесь о него.
	Вы отчаянно ищете дружественное лицо в толпе.
	Но слишком поздно: вы падаете на вокзальную платформу. Это конец.


### Липкие варианты

Поведение "только раз", конечно же, не всегда бывает желаемым. Так что нам нужен ещё один тип варианта выбора: "липкий". Липкий вариант просто не исчезает после выбора, и его можно создать с помощью знака `+` (вместо `*`) в начале.

	=== диван_гомера ===
		+	[Съесть ещё пончик]
			Ты ешь ещё один пончик. -> диван_гомера
		*	[Встать с дивана]
			Ты с трудом поднимаешься с дивана, чтобы пойти и написать эпичное стихотворение.
			-> END

Запасные варианты тоже могут быть липкими.

	=== цикл_беседы
		*	[Поговорить о погоде] -> обсуждение_погоды
		*	[Поговорить о детях] -> обсуждение_детей
		+	-> посидеть_ещё_молча

### Условные варианты выбора

Вы также можете вручную включать и выключать варианты. **ink** имеет довольно много встроенной логики, но легче всего проверить условие "видел ли игрок конкретную часть содержимого игры".

Каждый узел/стежок в игре имеет уникальный адрес (чтобы на него можно было перейти), и мы можем использовать тот же адрес, чтобы проверить видел ли игрок эту часть повествования.

	*		{not был_в_париже} 	[Ехать в Париж] -> был_в_париже
	+		{был_в_париже}	 	[Назад в Париж] -> был_в_париже

	*		{был_в_париже.встретил_эстель} [Позвонить мадам Эстель] -> звонок_эстель

Заметьте, что проверка `имя_узла` проходит, если *любой* из стежков этого узла был посещён ранее.

Также имейте в виду, что условия не перекрывают поведение "можно выбрать единожды", вам всё равно нужна липкость для возможности повторного выбора.

#### Дополнительно: множественные условия

Вы можете использовать несколько проверок для варианта выбора. В этом случае, чтобы вариант появился, необходимо, чтобы *все* проверки были пройдены успешно.

	*	{ not был_в_париже } 	[Ехать в Париж] -> был_в_париже
	+	{ был_в_париже } {not устал_от_парижа} [Вернуться в Париж] -> был_в_париже


#### Дополнительно: метки узла/стежка на самом деле счётчики количества посещений

Проверка:

	*	{видел_подсказку} [Обвинить мистера Джефферсона]

на самом деле проверяет *число*, а не флажок правда/ложь. Узел или стежок, использованный таким образом, в действительности - целочисленная переменная, содержащая количество раз, которые игрок видел содержимое по этому адресу.

Если оно не равно нулю, оно вернёт *истина* в такой проверке, как написана выше. Но проверка также может быть более конкретной:

	* {видел_подсказку > 3} [Немедленно арестовать мистера Джефферсона]

#### Дополнительно: больше логики

**ink** поддерживает гораздо более сложную логику и условия, чем описанные тут - смотри главу *Переменные и логика*.


## 6) Изменяющийся текст

### Текст может варьироваться

До сих пор всё содержимое игры, что мы видели, было статичным, фиксированные куски текста. Но содержимое также может меняться, прямо в момент вывода.

### Последовательности, циклы и другие альтернативы

Простейший способ варьировать текст - с помощью списков альтернатив, из которых он выбирается в соответствии с некоторыми правилами. **ink** поддерживает несколько видов. Списки записываются внутри фигурных скобок `{` и `}`, а элементы отделены друг от друга вертикальной чертой `|`.

Естественно, что они полезны лишь в таких местах, которые посещаются больше одного раза!

#### Типы альтернатив

**Последовательности** (по умолчанию):

Последовательность (или "останавливающий список") это список, который следит, сколько раз его посещали, и каждый раз показывает следующий элемент. Когда элементы списка заканчиваются, он продолжает показывать последний из них.

	Радио с шипением ожило. {"Три!"|"Два!"|"Один!"|Было слышно гудение белого шума от взрыва.|Но это был просто шум помех.}

	{Я купил кофе, заплатив пятифунтовой купюрой.|Я купил второй кофе для друга.|У меня больше не было денег на кофе.}

**Циклы** (отмечаются символом `&`):

Циклы похожи на последовательности, но они повторяют содержимое по кругу.

	Сегодня {&понедельник|вторник|среда|четверг|пятница|суббота|воскресенье}.


**"Одноразовые"** (отмечаются символом `!`):

Одноразовые списки похожи на последовательности, но когда у них заканчиваются элементы, они просто ничего не выводят. (Можете думать о них, как о последовательностях с пустым последним элементом.)

	Он рассказал мне анекдот. {!Я вежливо посмеялся.|Я улыбнулся.|Я поморщился.|Я пообещал себе больше не реагировать.}

**Перетасовки** (отмечаются символом `~`):

Перетасовки выдают случайный результат.

	Я подбросил монетку. {~Орёл|Решка}.

#### Возможности альтернатив

Списки альтернатив могут содержать пустые элементы.

	Я шагнул вперёд. {!||||Неожиданно погас свет. -> ой}

Списки альтернатив могут быть вложенными.

	Крысомедведь{&{, не тратя время попусту, | }ударил|царапнул} {&тебя|тебе прямо по {&ноге|руке|щеке}}.

Списки альтернатив могут включать переходы.

	Я {подождал.|ещё подождал.|вздремнул.|проснулся и подождал ещё.|сдался и ушёл. -> уйти_из_почты}

Также их можно использовать внутри текста выбора:

	+ 	"Приветствую, {&господин|месье Фогг|вас|кареглазка}!"[], воскликнул я.

(...с одним предостережением; вы не можете начать текст выбора с `{`, потому что это будет понято как условие.)

#### Примеры

Списки альтернатив можно использовать внутри циклов чтобы без больших усилий создавать видимость умного, управляющего своим состоянием геймплея.

Вот одноузловая версия игры "Прибей крота". Обратите внимание, мы используем одноразовые варианты выбора и запасной вариант, чтобы гарантировать, что крот не будет бегать по кругу, а игра обязательно завершится.

	=== прибей_крота ===
		{Я взвесил в руке молоток.|{~Мимо!|Пусто!|Неудача. Где же он?|Ага! Попался! -> END}}
		{&Крот|{&Мерзкий|Проклятый|Грязный} {&уродец|грызун}} {где-то здесь|где-то прячется|всё ещё не пойман|смеётся надо мной|всё ещё не пристукнут|обречён}. <>
		{!Я ему покажу!|В этот раз ему не скрыться!}
		*  [{&Ударить|Шмякнуть|Попробовать} верхний левый] 	-> прибей_крота
		*  [{&Врезать в|Засадить в|Треснуть} верхний правый] -> прибей_крота
		*  [{&Хряснуть|Обрушиться на} середину] -> прибей_крота
		*  [{&Залепить в|Бухнуть} нижний левый] 	-> прибей_крота
		*  [{&Заехать в|Шибануть} нижний правый] 	-> прибей_крота
		*  [] А потом ты свалился от голода. Крот победил тебя!
			-> END

в результате получим такую "игру":

	Я взвесил в руке молоток.
	Крот где-то здесь. Я ему покажу!

	1: Ударить верхний левый
	2: Врезать в верхний правый
	3: Хряснуть середину
	4: Залепить в нижний левый
	5: Заехать в нижний правый

	> 1
	Мимо!
	Мерзкий уродец где-то прячется. В этот раз ему не скрыться!

	1: Засадить в верхний правый
	2: Обрушиться на середину
	3: Бухнуть нижний левый
	4: Шибануть нижний правый

	> 4
	Пусто!

	Крот всё ещё не пойман.
	1: Треснуть верхний правый
	2: Хряснуть середину
	3: Залепить в нижний левый

	> 2
	Где же он?

	Проклятый грызун смеётся надо мной
	1: Врезать в верхний правый
	2: Бухнуть нижний левый

	> 1
	Ага! Попался!


А вот небольшой совет по образу жизни. Обратите внимание на липкий вариант выбора - телевиденье всегда соблазнительно:

	=== включить_телевизор ===
	Я {в первый раз|во второй раз|опять|ещё раз} включил телевизор, но там {не было ничего интересного, так что я снова выключил его|всё ещё не было ничего достойного|было ещё меньше интересного, чем раньше|показывали всякую фигню|была програма про акул, а я не люблю акул|ничего не было}.
	+	[Попытаться ещё раз]	-> включить_телевизор
	*	[Пойти прогуляться]		-> пойти_прогуляться

    === пойти_прогуляться ===
    -> END



#### Дополнительно: Многострочные списки альтернатив
Также, в **ink** есть другой формат описания списков для изменения блоков текста. Смотри главу "многострочные блоки" для более подробной информации.

### Условный текст

Текст может также меняться на основания логических проверок, точно также, как и варианты выбора.

	{встретил_блофельда: "Я видел его. Лишь на мгновение." }

и
	"Его настоящее имя {встретил_блофельда.узнал_его_имя: Франц|осталось в секрете}."

Такие условия могут располагаться на разных строках или внутри одной части текста. Они даже могут быть вложены друг в друга:

	{встретил_блофельда: "Я видел его. Лишь на мгновение. Его настоящее имя {встретил_блофельда.узнал_его_имя: Франц|осталось в секрете}." | "Я упустил его. Это какой-то особенно злой человек?" }

может выдать либо:

	"Я видел его. Лишь на мгновение. Его настоящее имя Франц."

или:

	"Я видел его. Лишь на мгновение. Его настоящее имя осталось в секрете."

или же:

	"Я упустил его. Это какой-то особенно злой человек?"

## 7) Запросы состояния игры

**ink** предоставляет несколько полезных запросов уровня игры в целом, которые можно использовать в логике условий. Они не вполне часть языка как такового, но они всегда доступны и автор игры не может их редактировать. В каком-то смысле, это "функции стандартной библиотеки" языка.

По соглашению их имена записываются прописными буквами.

### CHOICE_COUNT

`CHOICE_COUNT` возвращает количество вариантов выбора, созданных на настоящий момент в текущем куске игры. Вот например:

	*	{false} Вариант А
	*	{true} Вариант Б
	*	{CHOICE_COUNT() == 1} Вариант В

создаст два выбора - Б и В. Это может быть полезным для контроля за тем, сколько вариантов выбора игрок получит в конкретный ход.

### TURNS_SINCE

`TURNS_SINCE` возвращает количество ходов (формально, взаимодействий с игроком) с того момента, когда последний раз был посещён конкретный узел/стежок.

Значение 0 означает "был виден как часть текущего хода". Значение -1 означает "никогда не посещался". Любое другое положительное значение означает сколько ходов назад был виден элемент.

	*	{TURNS_SINCE(-> сон.интро) > 10} Ты чувствуешь себя уставшим... -> спать
	*	{TURNS_SINCE(-> смех) == 0}  Ты пытаешься перестать смеяться.

Обратите внимание, что параметр, переданный в `TURNS_SINCE` является "целью перехода" (со стрелкой `->`), а не просто названием узла (потому что адрес узла/стежка это число, количество посещений, а не место в повествовании...)

#### Дополнительно: ещё запросы

Вы можете создавать свои внешние функции, хотя их синтаксис будет несколько отличаться: см. в разделе про функции ниже.

# Часть 2: Сплетения

До сих пор мы писали ветвящиеся истории, используя простейший путь - "варианты выбора", которые ведут на "страницы".

Но такой подход требует от нас давать уникальные имена каждому месту в истории, на который можно перейти. Что замедляет процесс письма и отвращает от мелких ветвлений.

В **ink** есть намного более мощные средства написания, задуманные с целью упрощения потока повествования, который имеет однонаправленное движение "только вперёд" (как и бывает в большинстве историй, но *не бывает* в большинстве компьютерных программ).

Этот формат называется "сплетение" и он был создан на основе базового синтаксиса текста/выборов с двумя новыми возможностями: символа сборки `-` и вложенности выборов и сборок.

## 1) Сборки

### Сборки собирают потоки повествования снова вместе

Давайте вернёмся к первому примеру множественного выбора в начале этого документа.

	"В чём дело?" - спросил мой господин.
	*	"Я несколько устал[."]", повторил я.
		"В самом деле" - сказал он. "Как разрушительно."
	*	"Ни в чём, месье!"[] - ответил я.
		"Что ж, очень хорошо."
	*	"Я говорю, это путешествие отвратительно[."] и я не хочу больше в нём участвовать."
		"А", ответил он без раздражения. "Я вижу, ты раздосадован. Завтра всё наладится."
		
В настоящей игре, все эти три варианта выбора ведут к одному и тому же заключению - месье Фогг выходит из комнаты. Мы можем сделать это, используя сборку, без необходимости создания новых узлов или добавления новых переходов.

	"В чём дело?" - спросил мой господин.
	*	"Я несколько устал[."]", повторил я.
		"В самом деле" - сказал он. "Как разрушительно."
	*	"Ни в чём, месье!"[] - ответил я.
		"Что ж, очень хорошо."
	*	"Я говорю, это путешествие отвратительно[."] и я не хочу больше в нём участвовать."
		"А", ответил он без раздражения. "Я вижу, ты раздосадован. Завтра всё наладится."

	-	С этим месье Фогг вышел из комнаты.

Этот скрипт выдаст следующий результат:

	"В чём дело?" - спросил мой господин.

	1: "Я несколько устал."
	2: "Ни в чём, месье!"
	3: "Я говорю, это путешествие отвратительно."
	
	> 1
	"Я несколько устал", повторил я.
	"В самом деле" - сказал он. "Как разрушительно."
	С этим месье Фогг вышел из комнаты.

### Выборы и сборки формируют цепочки повествования

Мы можем связать эти секции "ветвление-и-сборка" вместе чтобы создать ветвящиеся последовательности, которые всегда двигаются вперёд.

	=== побег ===
	Я бежал сквозь лес, а собаки хватали меня за пятки.

		*	Я проверил бриллианты. [] Они были на месте, в кармане, и осознание этого подстегнуло мой бег. <>

		*	Я не стал останавливаться, чтобы передохнуть[.] и продолжил бежать. <>

		*	Я вскрикнул от радости. <>

	-	Дорога уже недалеко! Маки должен держать двигатель включённым, и я скоро буду в безопасности.

		*	Я добежал до дороги и огляделся []. И что бы вы думали?
		* 	Я должен сказать, что Маки обычно очень надёжный человек[]. Он никогда не подводил меня. Или, точнее, никогда раньше до этой ночи.

	-	Дорога была пуста. Маки нигде не было видно.

Это самый основной тип сплетения. Дальше в этой главе описаны дополнительные возможности, которые позволяют сплетениям быть вложенными, содержать обходные пути и ответвления, разветвляться внутри себя, и, помимо всего, ссылаться на ранее сделанные решения, чтобы влиять на более поздние.

#### Философия сплетений

Сплетения - это нечто большее, чем просто удобная инкапсуляция ветвящихся потоков. Они также позволяют писать более сложный текст. Пример `побег` выше уже можно пройти четырьмя возможными путями, а более сложные последовательности привнесут намного больше таких путей. Используя обычные переходы, автору приходится проверять ссылки, отслеживая переходы от точки до точки, и тут легко может вкрасться ошибка.

Со сплетением, повествование гарантированно начнётся с вершины и "ниспадёт" до самого низа. Ошибки в потоке невозможны в базовой структуре сплетения, а получающийся текст легко отследить, "скользя" по структуре. Это означает, что, в действительности, нет необходимости тестировать все ветви в игре, чтобы убедиться, что они работают так, как задумывалось.

Сплетения также позволяют с лёгкостью переписывать поворотные точки повествования. В частности, очень легко разбить предложение и вставить дополнительные варианты выбора для разнообразия или чтобы дать игроку дополнительную пищу для решений, и всё это без полной переделки повествования в целом.

## 2) Вложенные потоки

Сплетения, упоминавшиеся выше, имеют довольно простую, "плоскую" структуру. Что бы игрок ни делал, им требуется одинаковое количество ходов для прохождения. Однако, иногда определённые выборы приводят к чуть большей глубине или сложности.

Для этого мы позволяем сплетениям быть вложенными.

Тут следует предупреждение. Вложенные сплетения очень мощное и компактное средство, но они могут потребовать усилий для освоения!

### Варианты выбора можно вкладывать

Рассмотрим следующую сцену:

	- 	"Итак, Пуаро? Убийство или самоубийство?"
	*	"Убийство!"
	* 	"Самоубийство!"
	-	Миссис Кристи на секунду опустила манускрипт. Остальная группа писателей осталась сидеть с открытым ртом.

Первый предоставленный выбор - между "Убийство!" и "Самоубийство!". Если Пуаро провозгласит самоубийство, то дальнейших действий не предвидится, но в случае убийства необходимо задать следующий вопрос - кого он подозревает?

Мы можем добавить варианты через набор вложенных под-выборов. Мы говорим скрипту что новые варианты являются частью другого выбора с помощью двух звёздочек вместо одной.

	- 	"Итак, Пуаро? Убийство или самоубийство?"
		*	"Убийство!"
		 	"И кто сделал это?"
			* * 	"Детектив-инспектор Джапп!"
			* * 	"Капитан Хастингз!"
			* * 	"Я сам!"
		* 	"Самоубийство!"
		-	Миссис Кристи на секунду опустила манускрипт. Остальная группа писателей осталась сидеть с открытым ртом.

(Обратите внимание, что хорошим стилем будет также отбить строки, чтобы показать вложенность, хотя компилятору всё равно.)

И, если мы захотим добавить под-выборов в другую ветку, мы сделаем это похожим образом.

	- 	"Итак, Пуаро? Убийство или самоубийство?"
		*	"Убийство!"
		 	"И кто сделал это?"
			* *	"Детектив-инспектор Джапп!"
			* *	"Капитан Хастингз!"
			* *	"Я сам!"
		* 	"Самоубийство!"
			"Действительно, Пуаро? Вы полностью уверены?"
			* *	"Весьма уверен."
			* *	"Это совершенно очевидно."
		-	Миссис Кристи на секунду опустила манускрипт. Остальная группа писателей осталась сидеть с открытым ртом.


Теперь первоначальный выбор обвинения приведёт к последующим вопросам, специфичным для этой ветки, но в любом случае повествование сойдётся в точке сборки, где мы увидим появление миссис Кристи в роли камео.

Но что, если мы хотим более развёрнутую подсцену?

### Точки сборки тоже могут быть вложенными

Иногда речь идет не о расширении количества вариантов выбора, а о том, чтобы создать ещё один дополнительный такт в истории. Мы можем сделать это, вкладывая точки сборки точно также, как мы делали с вариантами выбора.

	- 	"Итак, Пуаро? Убийство или самоубийство?"
			*	"Убийство!"
			 	"И кто сделал это?"
				* * 	"Детектив-инспектор Джапп!"
				* * 	"Капитан Хастингз!"
				* * 	"Я сам!"
				- - 	"Вы, должно быть, шутите!"
				* * 	"Мон ами, я в высшей степени серьёзен."
				* *		"Если б только..."
			* 	"Самоубийство!"
				"Действительно, Пуаро? Вы полностью уверены?"
				* * 	"Весьма уверен."
				* *		"Это совершенно очевидно."
			-	Миссис Кристи на секунду опустила манускрипт. Остальная группа писателей осталась сидеть с открытым ртом.

Если игрок выберет ветку с убийством, то ему придётся сделать два выбора, один за другим - целое отдельное сплетение, созданное специально для них.

#### Дополнительно: Что делают сборки

Будем надеяться, сборки интуитивно понятны, но их поведение немного трудно описать словами: в целом, после того, как игрок сделал выбор, история находит следующую сборку ниже, на том же или более высоком уровне, и переходит на неё.

Основная идея такова: выборы разделяют пути истории, а сборки сводят их обратно вместе. (Отсюда и название "сплетение"!)

### Вы можете вкладывать столько уровней, сколько захотите

В примерах выше мы использовали два уровня вложенности: главный поток и второстепенный. Но нет никаких ограничений на то, насколько уровней в глубину вы можете пойти.

	-	"Расскажи нам историю, Капитан!"
		*	"Хорошо, морские волки. Вот история..."
			* * 	"Была тёмная и ненастная ночь..."
					* * * 	"...команда беспокоилась..."
							* * * *  "...и тогда они сказали своему капитану..."
									* * * * *		"...Расскажи нам историю, Капитан!"
		*	"Нет, уже поздно и пора спать."
 	-	Команда, все до одного, начала зевать.

Спустя время, это вкладывание становится трудно читать и править, так что хорошим стилем будет сделать переход на отдельный стежок, если такая ветка становится слишком громоздкой.

Но вы можете написать историю целиком внутри одного сплетения, по крайней мере в теории. 

### Пример: диалог, использующий вложенные узлы

Вот пример подлиннее:

	- Я взглянул на месье Фогга
	*	... и не смог больше сдерживаться.
		"Какова цель нашего путешествия, месье?"
		"Пари", ответил он.
		* * 	"Пари!"[] - повторил я.
				Он кивнул.
				* * *	"Но это же сущая глупость!"
				* * *	"Это серьёзное дело!"
				- - -	Он кивнул снова.
				* * *	"Но можем ли мы победить?"
						"Мы приложим максимум усилий, чтобы выяснить это", ответил он.
				* * *	"Скромное пари, я думаю?"
						"Двадцать тысяч фунтов", ответил он довольно ровно.
				* * *	Я решил больше не спрашивать ничего[.], и, даже после последнего вежливого покашливания, он так и не объяснил мне ничего. <>
		* * 	"А[."]," ответил я, не зная что сказать.
		- - 	После этого, <>
	*	... но ничего не сказал[] и <>
	- мы провели остаток дня в молчании.
	- -> END

И несколько его прохождений. Вот короткое:

	Я взглянул на месье Фогга

	1: ... и не смог больше сдерживаться.
	2: ... но ничего не сказал

	> 2
	... но ничего не сказал и мы провели остаток дня в молчании.

А вот более длинное:

	Я взглянул на месье Фогга

	1: ... и не смог больше сдерживаться.
	2: ... но ничего не сказал

	> 1
	... и не смог больше сдерживаться.
	"Какова цель нашего путешествия, месье?"
	"Пари", ответил он.

	1: "Пари!"
	2: "А."

	> 1
	"Пари!" - повторил я.
	Он кивнул.

	1: "Но это же сущая глупость!"
	2: "Это серьёзное дело!"

	> 2
	"Это серьёзное дело!"
	Он кивнул снова.

	1: "Но можем ли мы победить?"
	2: "Скромное пари, я думаю?"
	3: Я решил больше не спрашивать ничего.

	> 2
	"Скромное пари, я думаю?"
	"Двадцать тысяч фунтов", ответил он довольно ровно.
	После этого, мы провели остаток дня в молчании.

Мы надеемся, что это иллюстрируют изложенную выше философию, что сплетения предлагают компактный способ реализовать множественное ветвление с большим количеством выборов, но с гарантией того, что начав с начала, вы точно доберётесь в повествовании до конца!


## 3) Отслеживание сплетений

Иногда достаточно самой структуры сплетения. Но когда это не так, нам нужно немного больше контроля.

### Сплетения почти всегда не имеют адреса

По умолчанию строки содержимого сплетений не имеют какого-либо адреса или меток, что означает - на них нельзя перейти, а также проверить их посещение. В самой базовой структуры сплетения выбор пользователя меняет путь, которым он продвигается через сплетение и то, что он видит, но как только сплетение пройдено, этот путь забывается.

Но если нам требуется запомнить что игрок видел, мы можем это сделать - мы можем добавить метку там, где нам нужно, используя синтаксис `(имя_метки)`.

### Сборки и варианты выбора могут быть помечены.

Точки сборки на любом уровне вложенности можно пометить, используя скобки.

	-  (верх)

На помеченные сборки можно переходить или проверять их в условиях, точно так же, как узлы и стежки. Это означает, что вы можете использовать предыдущие решения для изменения позднего результата внутри сплетения, всё равно получая все преимущества чистого и надёжного продвижения вперёд.

Варианты выбора тоже можно пометить, точно так же, как точки сборки, используя скобки. Скобки меток должны идти перед условиями в строке.

Эти "адреса" можно использовать в условных проверках, что может быть удобным для создания вариантов выбора, которые разблокируются другими выборами.

	=== встреча_с_караульным ===
	Караульный хмурится на тебя.

	* 	(здороваться) [Поздороваться с ним]
		"Приветствую."
	*	(убирайся) "Убирайся с пути."[], говоришь ты караульному.

	- 	"Хмм", отвечает стражник.

	*	{здороваться} "Хороший денёк?"			// только если вы поздоровались

	* 	"Хмм?"[], отвечаешь ты.

	*	{убирайся} [Оттолкнуть его в сторону]	// только если вы угрожали ему
		Ты резко толкаешь его. Он в ответ пристально смотрит на тебя и вытаскивает меч!
		-> драка_с_караульным 					// этот путь уводит из сплетения

	-	"Мфф", говорит стражник, а затем протягивает тебе бумажный кулёк. "Ириску?"


### Область видимости

Внутри одного блока сплетения вы можете просто использовать имя метки. Снаружи блока вам нужен путь, на другой стежок внутри того же узла:

	=== узел ===
	= стежок_один
		- (точка_сборки) Некий текст.
	= стежок_два
		*	{стежок_один.точка_сборки} Вариант выбора

или вообще в другом узле:

	=== узел_один ===
	-	(сборка_один)
		* {узел_два.стежок_два.сборка_два} Вариант выбора

	=== узел_два ===
	= стежок_два
		- (сборка_два)
			*	{узел_один.сборка_один} Вариант выбора


#### Дополнительно: все выборы можно пометить

По правде, всё содержимое ink-скрипта является сплетением, даже если нет видимых сборок. Это означает, что вы можете пометить *любой* вариант выбора в игре меткой в скобках, а затем сослаться на него, используя синтаксис адресации. В частности, это значит, что вы можете проверить *какой* выбор игрок сделал, чтобы достичь конкретного результата. 

	=== драка_с_караульным ===
	...
	= кинуть_чтото
	*	(камень) [Кинуть в стражника камнем] -> кинуть
	* 	(песок) [Кинуть в стражника песком] -> кинуть

	= кинуть
	Ты швыряешь в стражника {кинуть_чтото.камень:камень|пригоршню песка}.


#### Дополнительно: Циклы в сплетении

Возможность ставить метки позволяет нам создавать циклы внутри сплетений. Вот стандартный подход для того, чтобы задать несколько вопросов NPC.

	- (варианты)
		*	"Где можно раздобыть униформу?"[], спрашиваешь ты у радостного стражника.
			"Вот здесь, в шкафчике." Он усмехается. "Но не думай, что она на тебя налезет."
		*	"Расскажи мне про систему безопасности."
			"Она древняя", заверяет тебя стражник, "как окаменелость."
		*	"Тут есть собаки?"
			"Сотни", отвечает стражник с зубастой ухмылкой. "Голодные дьяволы, да."
		// Мы требуем от игрока задать хотя бы один вопрос
		*	{цикл} [Хватит разговоров]
			-> всё
	- (цикл)
		// повторим пару раз до тех пор, пока стражнику не наскучит
		{ -> варианты | -> варианты | }
		Он чешет затылок.
		"Мы не можем стоять здесь и разговаривать весь день", объявляет он.
	- (всё)
		Ты благодаришь стражника и уходишь.


#### Дополнительно: переход на выбор

На выборы тоже можно переходить. Но такой переход ведёт к результату выбора этого варианта, *как если бы этот вариант был выбран игроком*. Так что печатаемый ответ будет игнорировать текст в квадратных скобках и, если вариант был "одноразовый", он будет помечен как посещённый.

	- (варианты)
	*	[Состроить гримасу]
		Ты состроил гримасу и стражник идёт на тебя! -> пихать

	*	(пихать) [Отпихнуть стражника в сторону] Ты отпихнул стражника, но он качнулся обратно.

	*	{пихать} [Приготовиться к бою] -> биться_со_стражником

	- 	-> варианты

выведет:

	1: Состроить гримасу
	2: Отпихнуть стражника в сторону

	> 1
	Ты состроил гримассу и стражник идёт на тебя! Ты отпихнул стражника, но он качнулся обратно.

	1: Приготовиться к бою

	>

#### Дополнительно: сборка непосредственно после варианта выбора

Следующее вполне правомерно и часто удобно.

	*	"Вы в порядке, месье?"[], спросил я.
		- - (впорядке) "Да, всё хорошо", ответил он.
	*	"У вас получилось с кроссвордом, месье?"[], спросил я.
		-> впорядке
	*	Я ничего не сказал[], и мой господин также промолчал.
	-	Мы снова ощутили дружественную тишину между нами.

Обратите внимание на точку сборки второго уровня сразу после первого выбора: там, в общем-то, нечего собирать, но она даёт нам удобное место для перехода после второго варианта выбора.


# Часть 3: Переменные и логика

До сих пор мы делали текст, выводящийся по условию, и условные выборы, используя проверки, основанные на том, какие части содержимого игры игрок видел на текущий момент.

**ink** также поддерживает переменные, как временные, так и глобальные, позволяющие хранить числовые и строковые данные или даже команды управления историей. Они полнофункциональны в смысле логики, и содержат дополнительные структуры, помогающие лучше организовать часто весьма сложную логику ветвящихся историй.

## 1) Глобальные переменные

Самые значимые переменные, и, вероятно, самые полезные для создаваемой истории, это переменные, хранящие некие уникальные значения состояния игры - всё что угодно, начиная с количества денег в кармане протагониста, и заканчивая значением, описывающим его состояние души.

Этот тип переменных называется "глобальным" потому, что к ним можно обратиться из любого места истории - как прочитать, так и записать в них новое значение. (Традиционно, в программировании принято избегать такого рода вещей, поскольку это позволяет одной части программы испортить работоспособность другой, не относящейся к ней, части. Но история - это история. И в историях всё строится на последствиях: что случилось в Вегасе редко остаётся там же.)

### Объявление глобальных переменных

Глобальные переменные можно объявить где угодно с помощью оператора `VAR`. Им необходимо присвоить стартовое значение, которое и определит тип этой переменной - целочисленный, с плавающей точкой, текстовое содержимое, или адрес внутри истории.

	VAR знание_о_лекарстве = false
	VAR имя_игрока = "Эмилия"
	VAR количество_зараженных_людей = 521
	VAR текущий_эпилог = -> все_умерли_от_чумы

### Использование глобальных переменных

Мы можем проверять глобальные переменные чтобы управлять вариантами выбора и выводить условный текст, таким же образом, как мы видели раньше.

	=== поезд ===
		Поезд трясся и грохотал. { настроение > 0:Впрочем, я чувствовал себя достаточно позитивно, чтобы не обращать внимания на болтанку|Это было невыносимо}.
		*	{ not знает_о_пари } "Но месье, почему мы путешествуем?"[], спросил я.
		* 	{ знает_о_пари} Я рзамышлял о нашем странном приключении[]. Будет ли оно успешным?

#### Дополнительно: хранение переходов в переменных

Команда перехода, на самом деле, сама является значением, которое можно хранить, менять и использовать для реального перехода по истории.

	VAR текущий_эпилог = -> все_умерли

	=== продолжать_или_выйти ===
	Сдадитесь или будете продолжать попытки спасти своё Королевство?
	*  [Продолжать!] 	-> ещё_больше_безнадёжной_рефлексии
	*  [Сдаться] 		-> текущий_эпилог


#### Дополнительно: Глобальные переменные видимы "снаружи"

К глобальным переменным можно получить доступ, а также менять их, из управляющей программы, точно также как и изнутри истории. Так что они предоставляют хороший способ взаимодействия межде ink-историей и игрой в целом, частью которой эта история является.

Слой **ink** часто является хорошим местом для хранения переменных, влияющих на геймплей. Нет никаких проблем с сохранением/загрузкой и сама история сможет взаимодействовать с этими значениями.


### Вывод значения переменной

Значение переменной можно вывести в содержимое игры, используя синтаксис, похожий на последовательности или условный текст:

	VAR дружественное_имя_игрока = "Джеки"
	VAR возраст = 23

	Моё имя Жан Паспарту, но мои друзья зовут меня {дружественное_имя_игрока}. Мне {возраст}.

Это может пригодиться при отладке. Более сложные способы вывода, основанные на логике и переменных, можно посмотреть в разделе про функции.

### Вычисление строк

Вы, должно быть, заметили, что выше было написано, что переменные могут содержать "текстовое содержимое", а не "строки". Это было сделано намерено, потому что строка, определённая в **ink**, может содержать ink-разметку - хотя, в конце концов, всё равно будет вычислена как строка. (Чёрт!)

	VAR цвет = ""

	~ цвет = "{~красный|синий|зелёный|жёлтый}" 
	
	{цвет} 
	
... выведет один из цветов - красный, синий, зелёный или жёлтый.

Обратите внимание, что как только содержимое такого рода "вычислено", его значение становится "липким". (Квантовое состояние схлопывается.) Так что вот такое:

	Головорез ударил тебя, так что искры посыпались из глаз - {цвет} и {цвет}.
	
... не приведёт к не очень интересному результату. (Если вы действительно хотите, чтобы это сработало, используйте текстовые функции, чтобы вывести название цвета!)

И это также причина того, что  

	VAR цвет = "{~красный|синий|зелёный|жёлтый}"

явно запрещено. Значение будет вычислено при компиляции истории, а это не то, что вы, возможно, хотите.


## 2) Логика

Очевидно, наши глобальные переменные не предназначены оставаться константами, так что нам нужен какой-нибудь синтаксис, чтобы их менять.

Поскольку, по-умолчанию, любой текст в **ink**-скрипте напрямую выводится на экран, нужен специальный символ для того, чтобы обозначить строку, содержимое которой предназначено для того, чтобы проделать какую-то работу с числами, для этого мы используем значок `~`.

Следующие команды назначают значения переменным:


	=== установить_всякие_переменные ===
		~ знает_про_пари = true
		~ x = (x * x) - (y * y) + c
		~ y = 2 * x * y

а следующим образом можно проверить условия:

	{ x == 1.2 }
	{ x / 2 > 4 }
	{ y - 1 <= x * x }
	
### Математика

**ink** поддерживает четыре базовых математических операции (`+`, `-`, `*` и `/`), а также `%` (или `mod`), который возвращает остаток от деления нацело.

Если требуются более сложные операции, можно написать функцию (используя, при необходимости, рекурсии) или вызвать внешнюю функцию из кода игры (для чего-то более продвинутого).

#### Дополнительно: числовые типы определяются неявно

Результаты действий - в частности, деления - типизируются на основе типа входящих аргументов. Так деление целых чисел вернёт целое число, но деление чисел с плавающей точкой вернёт результат с плавающей точкой.

	~ x = 2 / 3
	~ y = 7 / 3
	~ z = 1.2 / 0.5

получим, что `x` равно 0, `y` равно 2 и `z` равно 2.4.

### Сравнение строк

Несколько странно для текстового движка, но в **ink** мало что есть для работы со строками. Предполагается, что любое преобразование строк, которое может понадобится, управляется кодом игры (возможно, через внешние функции). Но мы поддерживаем три базовых типа сравнения - равенство, неравенство и поиск подстроки (которое мы называем `?` по причинам, которые станут яснее в следующих разделах).

Следующие проверки все возвращают положительные результат:
	
	{ "Да, пожалуйста." == "Да, пожалуйста." }
	{ "Нет, спасибо." != "Да, пожалуйста." }
	{ "Да, пожалуйста." ? "пожалуй" }
	

## 3) Условные блоки (if/else)

Мы уже видели условия, позволяющие управлять вариантами выбора и содержимым истории. В **ink** также есть эквиваленты нормальной структуры if/else-if/else (если/иначе-если/иначе).

### Простой 'if' (если)

Синтаксис условного оператора `if` берёт своё начало из условий, которые мы использовали до сих пор, и основан на синтаксисе со скобками `{`...`}`, обозначающими, что нечто требует проверки.

	{ x > 0:
		~ y = x - 1
	}

Обратные (иначе) условия тоже можно указать:

	{ x > 0:
		~ y = x - 1
	- else:
		~ y = x + 1
	}

### Расширенные блоки if/else

Синтаксис выше, на самом деле, частный случай более общей структуры, что-то вроде оператора "switch" в других языках программирования:

	{
		- x > 0:
			~ y = x - 1
		- else:
			~ y = x + 1
	}

И, используя эту форму, мы можем добавить 'else-if' условия:

	{
		- x == 0:
			~ y = 0
		- x > 0:
			~ y = x - 1
		- else:
			~ y = x + 1
	}

(Обратите внимание, здесь, как и везде, пробелы используются исключительно для удобства чтения и не несут никакой синтаксической нагрузки.)

### Блоки переключения

А также есть настоящий оператор переключения (как `switch` в других языках): 

	{ x:
	- 0: 	ноль 
	- 1: 	один 
	- 2: 	два 
	- else: куча
	}
	

#### Пример: содержимое, релевантное контексту

Отметим, что эти проверки не обязательно должны основываться на переменных. Они могут использовать счётчики посещений, точно так же, как и любые другие условия. Конструкции, подобные указанным ниже, довольно часто используются для логики вида "сделай нечто, что отвечает текущему состоянию игры":

	=== сон ===
		{
			- посетил_змей && not сон_про_змей:
				~ страх++
				-> сон_про_змей

			- посетил_польшу && not сон_про_польское_пиво:
				~ страх--
				-> сон_про_польское_пиво

			- else:
				// сны про завтрак не оказывают эффекта
				-> сон_про_мармелад
		}

Преимущество этого синтаксиса заключается в простоте расширения и приоритизации.


### Условные блоки не ограничены только лишь логикой

Условные блоки можно использовать, чтобы управлять не только логикой игры, но и её содержимым:

	Я уставился на месье Фогга.
	{ знает_про_пари:
		<> "Но вы же не серьёзно?", спросил я.
	- else:
		<> "Но должна же быть причина для такого путешествия", заметил я.
	}
	Он ничего не ответил, изучая свою газету с тем же тщанием, с каким энтомолог изучает новое пополнение своей коллекции.

Вы даже можете поместить варианты выбора внутрь условного блока:

	{ дверь_открыта:
		* 	Я направился к выходу из купе[] и мне показалось, что я слышу как мой господин тихонько цокает языком. -> идти_наружу
	- else:
		*	Я попросил разрешения удалиться[], и месье Фогг выглядел удивлённым. 	-> открыть_дверь
		* 	Я встал и открыл дверь[]. Месье Фогг своим видом показал, что его не беспокоит этот маленький бунт. -> открыть дверь
	}

...но обратите внимание, что ограниченный синтаксис сплетения и вложений выше не случаен: во избежание путаницы в различных областях вложений вам не разрешается использовать точки сборки внутри условных блоков.

### Многострочные блоки

Существует ещё один класс многострочных блоков, который расширяет функционал списков альтернатив, о которых говорилось раньше. Всё последующее вполне правомерно и делает именно то, что вы можете предположить:

 	// Последовательность: идём через альтернативы и останавливаемся на последней
	{ stopping:
		-	Я вошёл в казино.
		-	Я зашёл в казино ещё раз.
		-	Я опять зашёл внутрь.
	}

	// Перетасовка: показать случайный вариант
	Сидя за столом, я вытащил карту. <>
	{ shuffle:
		- 	Туз червей.
		- 	Король пик.
		- 	Двойка бубен.
			'Вы проиграли!' - зло усмехнулься крупье.
			-> покинуть_казино
	}

	// Циклический: показать каждый по очереди и далее по кругу
	{ cycle:
		- Я затаил дыхание.
		- Я нетерпеливо ждал.
		- Я замер.
	}

	// Единожды: показать каждый, один раз, по очереди до тех пор, пока все не будут показаны
	{ once:
		- Продержится ли моя удача?
		- Смогу ли я выиграть расклад?
	}

## 4) Временные переменные

### Временные переменные — для мелких вычислений

Иногда использование глобальной переменной слишком громоздко. **ink** предоставляет временные переменные для быстрых вычисление всякого.

	=== рядом_с_северным_полюсом ===
		~ temp количество_тёплых_вещей = 0
		{ одеяло:
			~ количество_тёплых_вещей++
		}
		{ наушники:
			~ количество_тёплых_вещей++
		}
		{ перчатки:
			~ количество_тёплых_вещей++
		}
		{ количество_тёплых_вещей > 2:
			Несмотря на снег, я чувствовал себя неприлично уютно.
		- else:
			Этой ночью я замёрз сильнее, чем когда-либо за всю мою жизнь.
		}

Значение временной переменной выбрасывается после того, как история покинет стежок, в котором эта переменная была определена.

### Узлы и стежки могут принимать параметры

Особенно полезной формой временной переменной является параметр. Любому узлу или стежку можно передать значение в виде параметра.

	*	[Обвинить Хастинга]
			-> обвинить("Хастинга")
	*	[Обвинить миссис Блэк]
			-> обвинить("Клаудию")
	*	[Обвинить себя]
			-> обвинить("себя")

	=== обвинить(кого) ===
		"Я обвиняю {кого}!" — объявил Пуаро.
		"Правда?" — ответил Япп, — "{кого == "себя":Вы сделали это?|{кого}?}"
		"А почему нет?" — откликнулся Пуаро. 	


... а также вам понадобятся параметры, если вы захотите передать временное значение из одного стежка в другой!

#### Пример: определение рекурсивного узла

Временные переменные можно безопасно использовать в рекурсии (а глобальные - нет), так что следующий код вполне работает.

	-> добавь_единицу_до_ста(0, 1)

	=== добавь_единицу_до_ста(всего, x) ===
		~ всего = всего + x
		{ x == 100:
			-> конец(всего)
		- else:
			-> добавь_единицу_до_ста(всего, x + 1)
		}

	=== конец(всего) ===
		"Результат будет {всего}!" — провозглашаете вы.
		Гаусс в ужасе смотрит на вас.
		-> END


(На самом деле, такого рода определения настолько удобны, что **ink** предоставляет специальный тип узлов, который — достаточно изобретательно — называется `функцией`, имеет определённые ограничения и может возвращать значение. Смотрите раздел ниже.)


#### Дополнительно: пересылка перехода как параметра

Адрес узла/стежка является значением определённого типа, обозначенным символами `->`, которое можно сохранить в переменной и передавать куда необходимо. Поэтому следующий код вполне легитимен и часто бывает полезным:

	=== спать_в_хижине ===
		Ты ложишься и закрываешь глаза.
		-> сон_вообще (-> проснуться_в_хижине)

	===	 сон_вообще (-> пробуждение)
		Вы спите, возможно видите сны, и т.д., и т.п.
		-> пробуждение

	=== проснуться_в_хижине
		Ты поднимаешься на ноги, готовый продолжить путешествие.

...но обратите внимание на `->` в определении `сон_вообще` : это один из случаев в **ink**, когда параметр должен быть типизирован, так как слишком легко, в противном случае, случайно написать следующее:

	=== спать_в_хижине ===
		Ты ложишься и закрываешь глаза.
		-> сон_вообще (проснуться_в_хижине)

... что передаст в узел, реализующий сон, счётчик посещений `проснуться_в_хижине`, а потом попробует перейти на значение этого счётчика.





## 5) Функции

Использование параметров в узлах означает, что они и так уже почти функции в обычном смысле, но им не хватает пары ключевых вещей — стека вызовов и возвращаемых значений.

**ink** позволяет реализовать функции: это узлы со следующими ограничениями и возможностями:

Функция:
- не может содержать стежки
- не может использовать переходы или предлагать выбор
- может вызывать другие функции
- может включать выводимый текст
- может возвращать значение любого типа
- может безопасно использовать рекурсию

(Некоторые из ограничений могут показаться весьма суровыми, но если хотите узнать о возможностях, позволяющих использовать стек вызовов, но более ориентированных на построение истории, ознакомьтесь с главой о Туннелях.)

Возврат значения из функции реализуется с помощью оператора `~ return`.

### Определение и вызов функций

Чтобы определить функцию, просто объявите узел функцией:

	=== function на_всё_говорить_да ===
		~ return true

	=== function линт(a, b, k) ===
		~ return ((b - a) * k) + a

Функции вызываются по имени, и со скобками, даже если у них нет параметров:

	~ x = линт(2, 8, 0.3)

	*	{на_всё_говорить_да()} 'Да.'

Как и в любом другом языке, функция, завершившись, возвращает исполнение в ту точку, откуда она была вызвана. И, несмотря на то, что функции не позволяется перенаправлять течение истории, функции всё же могут вызывать другие функции.

	=== function ничего_не_отрицать ===
		~ return на_всё_говорить_да()

### Функции не обязаны возвращать значение

Функции не обязательно должны возвращать значение и попросту могут делать что-то, что удобно завернуть в функцию:

	=== function вред(x) ===
		{ жизнь < x:
			~ жизнь = 0
		- else:
			~ жизнь = жизнь - x
		}

...но всё жепомните, что функция не может изменить повествование, так что код выше может предотвратить отрицательные значения для показателя жизненной силы, но не может "убить" игрока, у которого он достиг нуля.

### Функции можно вызывать внутри строки текста

Функции можно вызывать на строках с `~`, но точно так же их можно вызывать непосредственно в тексте повествования. В этом случае возвращаемое значение (если оно есть) распечатывается в текст (как и что угодно ещё, что функция захочет распечатать). Если возвращаемого значения нет,  ничего не выводится.

Текст результата по-умолчанию "вклеивается", так что следующее:

	Месье Фогг выглядел {описать_здоровье(здоровье)}.

	=== function описать_здоровье(x) ===
	{
	- x == 100:
		~ return "полным сил"
	- x > 75:
		~ return "бодрым"
	- x > 45:
		~ return "несколько уставшим"
	- else:
		~ return "угнетённым и подавленным"
	}

выведет:

	Месье Фогг выглядел угнетённым и подавленным.

#### Примеры

Например, вы можете написать так:

	=== function max(a,b) ===
		{ a < b:
			~ return b
		- else:
			~ return a
		}

	=== function exp(x, e) ===
		// возвращает x в степени e, где e - целое
		{ e <= 0:
			~ return 1
		- else:
			~ return x * exp(x, e - 1)
		}

Затем:

	Наибольшее значение между 2^5 и 3^3 равно {max(exp(2,5), exp(3,3))}.

И получить:

	Наибольшее значение между 2^5 и 3^3 равно 32.


#### Пример: написание чисел словами

Следующий пример довольно длинный, но подобная функция присутствует практически в каждой ink-игре из выпущенных до сих пор. (Вспомните, что помеченная дефисом строка внутри многострочного блока в фигурных скобках это либо "условие, которое нужно проверить", либо, если за фигурной скобкой сразу следует переменная, то "значение, с которым следует сравнить".)

    === function число_словами(x) ===
    {
        - x >= 1000:
            {число_словами(x / 1000)} {числоформа(x/1000, "тысяча", "тысячи", "тысяч")} { x mod 1000 > 0:{число_словами(x mod 1000)}}
        - x == 0:
            ноль
        - else:
            {x >= 100:
                {x / 100:
                    - 1: сто
                    - 2: двести
                    - 3: триста
                    - 4: четыреста
                    - 5: пятьсот
                    - 6: шестьсот
                    - 7: семьсот
                    - 8: восемьсот
                    - 9: девятьсот
                }
                ~ x = x mod 100
                { x > 0:<> }
            }
            { x >= 20:
                { x / 10:
                    - 2: двадцать
                    - 3: тридцать
                    - 4: сорок
                    - 5: пятьдесят
                    - 6: шестьдесят
                    - 7: семьдесят
                    - 8: восемьдесят
                    - 9: девяносто
                }
                { x mod 10 > 0:<> }
            }
            { x < 10 || x > 20:
                { x mod 10:
                    - 1: одна
                    - 2: две
                    - 3: три
                    - 4: четыре        
                    - 5: пять
                    - 6: шесть
                    - 7: семь
                    - 8: восемь
                    - 9: девять
                }
            - else:     
                { x:
                    - 10: десять
                    - 11: одиннадцать       
                    - 12: двенадцать
                    - 13: тринадцать
                    - 14: четырнадцать
                    - 15: пятнадцать
                    - 16: шестнадцать      
                    - 17: семнадцать
                    - 18: восемнадцать
                    - 19: девятнадцать
                }
            }
    }
    
    === function числоформа(x, один, два, много) ===
    {x mod 20:
        - 1: {один}
        - 2: {два}
        - 3: {два}
        - 4: {два}
        - else: {много}
    }

что позволит нам писать примерно так:

	~ цена = 15

	Я вытащил монеты из кармана и медленно пересчитал, их оказалось {число_словами(цена)}. 
    "О, не беспокойтесь!" - ответил торговец, - "Я возьму половину." 
	С этими словами он отсчитал нужное количество, - "Так, {число_словами(цена / 2)}...", - а остальное подтолкнул обратно ко мне.

**Прим. переводчика:** *В русском языке числительные склоняются по падежам и родам, поэтому функция получилась неуниверсальной (только женский род и именительный падеж). Но ничто не мешает доработать её.*

### Параметры можно передавать по ссылке

Параметры функций также могут быть переданы "по ссылке", это означает, что фунция сможет на самом деле менять значение переданной ей переменной, а не будет создавать временную переменную с этим значением.

Например, большинство игр от **inkle** включают в себя следующий код:

	=== function изменить(ref x, k) ===
		~ x = x + k

И строки подобные этим:

	~ золото = золото + 7
	~ здоровье = здоровье - 4

превращаются в:

	~ изменить(золото, 7)
	~ изменить(здоровье, -4)

что несколько легче читается, и (что более полезно) можно выполнить прямо на строке для максимальной компактности.

	*   Я съел печенье[] и почувствовал прилив сил. {изменить(здоровье, 2)}
	*   Я отдал печенье месье Фоггу[] и он умял его самым непристойным образом. {изменить(здоровье_фогга, 1)}
	-   <> Затем мы продолжили наш путь.

Обёртывание простых операций в функцию также позволит легко вывести отладочную информацию, если она вдруг понадобится.




##  6) Константы


### Глобальные константы

Интерактивные истории часто полагаются на конечные автоматы, отслеживающие в каком состоянии находится процесс более высокого уровня. Существует масса способов осуществить это, но самым удобным будет использование констант.

Иногда удобно определить константы в виде строк, чтобы их можно было напечатать, во время игры или же для отладки.

	CONST ХАСТИНГС = "Хастингс"
	CONST ПУАРО = "Пуаро"
	CONST ДЖАПП = "Джапп"
	
	VAR текущий_главный_подозреваемый = ХАСТИНГС
	
	=== пересмотр_улик ===
		{ найдена_окровавленная_перчатка_джаппа:
			~ текущий_главный_подозреваемый = ПУАРО
		}
		Текущий подозреваемый: {текущий_главный_подозреваемый}
	
Иногда удобно назначить константам значения:

	CONST ПИ = 3.14
	CONST ЦЕННОСТЬ_ДЕСЯТИФУНТОВОЙ_БАНКНОТЫ = 10
	
А иногда значения полезны несколько по-другому:

	CONST ВЕСТИБЮЛЬ = 1
	CONST ЛЕСТНИЦА = 2
	CONST КОРИДОР = 3
	
	CONST У_АГЕНТА = -1
	
	VAR местонахождение_секретного_агента = ВЕСТИБЮЛЬ
	VAR местонахождение_дипломата = КОРИДОР
	
	=== проверить_прогресс ===
	{  местонахождение_секретного_агента = местонахождение_дипломата:
		Секретный агент схватил дипломат!
		~ местонахождение_дипломата = У_АГЕНТА  
		
	-  местонахождение_секретного_агента < местонахождение_дипломата:
		Секретный агент продвинулся вперёд.
		~ местонахождение_секретного_агента++
	}
	
Константы - это просто способ дать вам возможность назначать различным состояниям истории легкочитаемые имена.

## 7) Тема повышенной сложности: Логика на стороне игры

Существует два основных способа взаимодействия между игрой и движком **ink** (который в игру *встроен*). Объявленные внешние функции в ink позволяют вам напрямую вызывать C#-функции в игре, и "наблюдатели переменных" - callback-функции, которые вызываются когда та или иная ink-переменная меняется. Оба способа описаны в [Как запустить вашу ink-игру](RunningYourInk_Ru.md).

# Часть 4: Расширенные средства управления повествованием


## 1) Туннели

По умолчанию, структура **ink**-истории - "плоское" дерево выборов, разветвляющееся и соединяющееся вновь, возможно иногда зацикливающееся, но история всегда происходит "в определённом месте".

Но такая плоская структура делает некоторые вещи сложными для реализации. Например, представьте игру, в которой возможно следующее взаимодействие:

	=== пересечение_линии_перемены_даты ===
	*	"Месье!"[], - вскричал я, внезапно ужаснувшись, - "Я только что понял. Мы пересекли международную линию перемены даты!"
	-	Месье Фогг слегка приподнял бровь. "Я подумал об этом."
	*	Я вытер пот со лба[]. Фухх!
	* 	Я кивнул, успокоившись[]. Ну конечно он подумал.
	*	Я выругался себе под нос[]. Опять он меня унизил!

...однако, это может произойти в нескольких различных местах в истории. Мы же не хотим писать одно и то же в нескольких местах, но когда этот кусок истории завершится, ему понадобится знать, куда возвращаться. Мы можем решить эту проблему с помощью параметров:

	=== пересечение_линии_перемены_даты(-> вернуться_к) ===
	...
	-	-> вернуться_к 

	...

	=== в_гонолулу ===
	Мы прибыли на большой остров Гонолулу.
	- (постскриптум) 
		-> пересечение_линии_перемены_даты(-> всё)
	- (done)
		-> END 

	...
	
	=== на_остров_питкэрн ===
	Корабль рассекал волны, направляясь к крошечному островку.
	- (постскриптум) 
		-> пересечение_линии_перемены_даты(-> всё)
	- (всё)
		-> END 
	
Обе эти локации смогут теперь вызвать и исполнить один и тот же фрагмент повествования, но когда этот фрагмент завершится, они вернутся туда, куда следует, чтобы двигаться дальше.

Но что, если фрагмент, который мы вызываем, более сложный - что, если он содержит несколько узлов? Если использовать приведённый выше подход, то нам придётся передавать параметр "вернуться-к" из узла в узел, чтобы гарантировать, что мы всегда знаем, куда вернуться.

Чтобы не делать это вручную, **ink** включает в язык этот подход, вместе с новым типом перехода, который действует во многом как подпрограмма, и называется "туннель".

### Туннели запускают под-истории

По синтаксису туннель выглядит как переход с ещё одним переходом в конце:

	-> пересечение_линии_перемены_даты ->
	
Это означает "выполнить часть истории пересечение_линии_перемены_даты,  а затем продолжить дальше отсюда". 
	
Внутри самого туннеля синтаксис проще примера с параметром: всё, что нам нужно сделать - закончить туннель, используя `->->`, что означает, по существу, "продолжить дальше".

	=== пересечение_линии_перемены_даты === 
	// это туннель!
	...
	- 	->->

Обратите внимание, что узлы туннелей не объявляются таковыми, поэтому компилятор не может проверить, что туннель действительно заканчиватся  записью `->->`, это возможно лишь при выполнении. Так что вам нужно быть осторожными при написании, чтобы повествование, уйдя в туннель, смогло вернуться обратно.

Туннели можно соединять в цепочки или заканчивать обычным переходом:

	... 
	// тут мы запускаем туннель, а затем переходим на "всё"
	-> пересечение_линии_перемены_даты -> всё
	...

	... 
	// а здесь запускаем туннель, затем ещё один, а потом переходим на "всё"
	-> пересечение_линии_перемены_даты -> проверить_здоровье_фогга -> всё
	...

Туннели могут быть вложенными, так что следующее вполне легально:

	=== равнины ===
	= ночное_время
		Тёмная трава пружинит под твоими ногами.
		+	[Спать]
			-> спать_тут -> проснуться_тут -> дневное_время
	= дневное_время 
		Время продолжать путь.
		
	=== проснуться_тут ===
		Ты пробуждаешься с восходом солнца.
		+	[Съесть что-нибудь]
			-> съесть_что_нибудь ->
		+	[Двинуться дальше]
		-	->->

	=== спать_тут ===
		Ты ложишься и стараешься закрыть глаза.
		-> атака_монстра -> 
		А теперь время поспать.
		-> сон ->
		->->
		
... и так далее.

				

#### Дополнительно: Туннели используют стек вызовов

Туннели используют стек вызовов, так что они могут безопасно рекурсировать.


## 2) Нити

До сих пор всё в **ink** было довольно-таки линейным, несмотря на на все ветвления и переходы. Но на самом деле автор может "распилить" историю на несколько различных подразделов с тем, чтобы покрыть больше возможных действий игрока.

Мы называем это "нанизыванием" (как бусины на нить), это похоже на связывание воедино содержимого из нескольких разных мест.

Обратите внимание, что это действительно возможность повышенной сложности: написание историй становится весьма более сложным, когда используются нити.

### Нити связывают несколько частей воедино

Нити позволяют вам скомпоновать части содержимого из нескольких источников за один приём. Например:

    == пример_нити ==
    У меня болела голова. В этих нитях чёрт ногу сломит.
    <- беседа
    <- прогулка


    == беседа ==
    Это был напряжённый момент для нас с Монти.
     * "Что у тебя было сегодня на обед?"[] - спросил я.
        "Ветчина и яичница," - ответил он.
     * "Неплохая погода сегодня"[] - сказал я.
        "Я видел и получше," - ответил он.
     - -> дом

    == прогулка ==
    Мы продолжали идти по пыльной дороге.
     * [Продолжать идти]
        -> дом

    == дом ==
    Вскоре мы добрались до его дома.
    -> END

Этот код позволяет нескольким частям истории собраться в единый раздел:

    У меня болела голова. В этих нитях чёрт ногу сломит.
    Это был напряжённый момент для нас с Монти.
    Мы продолжали идти по пыльной дороге.
    1: "Что у тебя было сегодня на обед?"
    2: "Неплохая погода сегодня"
    3: Продолжать идти

Встретив указание на нить, такое как `<- беседа`, компилятор как бы разветвляет повествование. Первая ветвь запустит содержимое узла  `беседа`, собрав все варианты выбора, которые встретит. Как только компилятор исчерпает содержимое узла, он запустит вторую ветвь. 

Всё содержимое будет собрано воедино и выведено игроку. Но когда выбор сделан, движок перейдёт на соответствующую ветвь истории и отбросит все остальные.

Имейте в виду, что глобальные переменные *не* разветвляются. Это включает и счётчики посещений узлов и стежков.

### Использование нитей

В обычной истории нити могут вообще никогда не понадобиться.

Но в играх с большим количеством независимо движущихся частей, нити быстро становятся незаменимым инструментом. Представьте себе игру, в которой персонажи двигаются по карте независимо друг от друга, в такой игре главная локация для комнаты может выглядеть примерно так:

	CONST КОРИДОР = 1
	CONST ОФИС = 2

	VAR где_игрок = КОРИДОР
	VAR где_генерал = КОРИДОР
	VAR где_доктор = ОФИС

	== проверить_положение_игрока
		{
			- где_игрок == КОРИДОР: -> коридор
		}

	== коридор ==
		<- кто_здесь
		*	[Ящики стола]	-> обыскать_ящики
		* 	[Гардероб] 		-> обыскать_гардероб
		*	[Идти в офис] 	-> в_офис
		-	-> проверить_положение_игрока
	= обыскать_ящики
		// и т.д. и т.п...

	// А это нить, которая смешивает диалоги с персонажами, которые находятся в той же комнате, что и вы

	== кто_здесь
		{ где_генерал == где_игрок:
			<- диалог_генерал
		}
		{ где_доктор == где_игрок:
			<- диалог_доктор
		}

	== диалог_генерал
		*	[Спросить генерала об окровавленном ноже]
			"Всё что я могу сказать - это плохо кончится."
		-	-> проверить_положение_игрока

	== диалог_доктор
		*	[Спросить доктора об окровавленном ноже]
			"В крови ведь нет ничего странного. Разве нет?"
		-	-> проверить_положение_игрока



Особо обратите внимание на тот факт, что нам приходится явно указывать для игрока, который прошёл под-историю в нити, способ возврата в основное повествование. В большинстве случаев, нити либо потребуется параметр, содержащий точку возврата, либо же нить попросту завершит текущую главу основной истории.


### Когда заканчивается нить?

Отдельные нити заканчиваюся, когда у них заканчивается содержимое. И заметьте, они собирают варианты выбора для того, чтобы показать их позже (в отличие от туннелей, которые собирают варианты выбора, показывают их и следуют выбранным вариантам до тех пор, пока не встретят явный выход, возможно, несколькими ходами позднее).

Иногда в нити просто нет содержания - возможно, с персонажем не о чем больше общаться, или же мы просто его ещё не написали. В таком случае, нам следует явно отметить, что нить закончилась.

Если мы этого не сделали, то конец содержимого окажется ошибкой или "подвисшей" нитью, о чём мы предпочли бы узнать от компилятора.

### Использование `-> DONE`

Итак, в случаях, когда мы хотим пометить конец нити, мы используем `-> DONE`, что значит "повествование намеренно заканчивается здесь".

Обратите внимание, что в `-> DONE` нет необходимости, если код заканчивается вариантами выбора, у которых не прошли условия. Движок считает это валидным, намеренным окончанием повествования.

**Вам не нужен `-> DONE` в нити после того, как вариант выбора был выбран**. Как только он выбран, нить уже не нить, а снова обычное повествование.

Использование `-> END` в данном случае завершит не нить, а всю историю целиком. (И это, собственно, и есть причина, для чего нужны два разных способа закончить повествование.)


#### Пример: добавление одного и того же варианта выбора в разные места

Нити можно использовать, чтобы добавить один и тот же вариант выбора в разные места истории. Если вы используете их таким образом, то нормально будет передать переход как параметр, чтобы история "знала", куда идти после того, как выбор сделан.

	=== снаружи_дома
	Крыльцо. Дом пахнет. Убийством. И лавандой.
	- (верх)
		<- просмотреть_заметки_по_делу(-> верх)
		*	[Пройти во входную дверь]
			Я шагнул внутрь дома.
			-> коридор
		*	[Понюхать воздух]
			Я ненавижу лаванду. Она заставляет меня думать о мыле. А мыло заставляет меня думать о моём браке.
			-> верх

	=== коридор
	Коридор. Входная дверь открыта на улицу. Маленький комод.
	- (верх)
		<- просмотреть_заметки_по_делу(-> верх)
		*	[Выйти через переднюю дверь]
			Я шагнул наружу под холодный солнечный свет.
			-> снаружи_дома
		* 	[Открыть комод]
			Ключи. Ещё ключи. И ещё ключи. Сколько замков нужно этим людям?
			-> верх

	=== просмотреть_заметки_по_делу(-> вернуться_к)
	+	{not всё || TURNS_SINCE(-> всё) > 10}
		[Просмотреть мои заметки по делу]
		// условие гарантирует, что вы не будете получать этот вариант выбора постоянно
		{Я|Я снова} пролистал заметки, которые сделал на текущий момент. Всё ещё нет явных подозреваемых.
	-	(всё) -> вернуться_к

Обратите внимание, что это отличается от туннеля, который проигрывает такой же блок текста, но не даёт игроку какого-либо выбора. Так что такой код:

	<- воспоминания_детства(-> дальше)
	*	[Выглянуть в окно]
	 	Я задумался под стук колёс...
	 - (дальше) И тут прозвучал свисток...

может делать в точности то же, что и этот:

	*	[Вспомнить детство]
		-> вспомнить_разное ->
	*	[Выглянуть в окно]
		Я задумался под стук колёс...
	- 	(дальше) И тут прозвучал свисток... 	

но как только ответвление, в которое мы уводим игрока, будет включать в себя множественный выбор или логику с условиями (или, конечно, любое текстовое содержание!), версия с нитью становится более практичной.


#### Пример: organisation of wide choice points

A game which uses ink as a script rather than a literal output might often generate very large numbers of parallel choices, intended to be filtered by the player via some other in-game interaction - such as walking around an environment. Threads can be useful in these cases simply to divide up choices.

```
=== the_kitchen
- (верх)
	<- drawers(-> верх)
	<- cupboards(-> верх)
	<- room_exits
= drawers (-> goback)
	// choices about the drawers...
	...
= cupboards(-> goback)
	// choices about cupboards
	...
= room_exits
	// exits; doesn't need a "return point" as if you leave, you go elsewhere
	...
```

# Part 5: Advanced State Tracking

Games with lots of interaction can get very complex, very quickly and the writer's job is often as much about maintaining continuity as it is about content.

This becomes particularly important if the game text is intended to model anything - whether it's a game of cards, the player's knowledge of the gameworld so far, or the state of the various light-switches in a house.

**ink** does not provide a full world-modelling system in the manner of a classic parser IF authoring language - there are no "objects", no concepts of "containment" or being "open" or "locked". However, it does provide a simple yet powerful system for tracking state-changes in a very flexible way, to enable writers to approximate world models where necessary.

#### Note: New feature alert!

This feature is very new to the language. That means we haven't begun to discover all the ways it might be used - but we're pretty sure it's going to be useful! So if you think of a clever usage we'd love to know!


## 1) Basic Lists

The basic unit of state-tracking is a list of states, defined using the `LIST` keyword. Note that a list is really nothing like a C# list (which is an array).

For instance, we might have:

	LIST kettleState = cold, boiling, recently_boiled

This line defines two things: firstly three new values - `cold`, `boiling` and `recently_boiled` - and secondly, a variable, called `kettleState`, to hold these states.

We can tell the list what value to take:

	~ kettleState = cold

We can change the value:

	*	[Turn on kettle]
		The kettle begins to bubble and boil.
		~ kettleState = boiling

We can query the value:

	*	[Touch the kettle]
		{ kettleState == cold:
			The kettle is cool to the touch.
		- else:
		 	The outside of the kettle is very warm!
		}

For convenience, we can give a list a value when it's defined using a bracket:

	LIST kettleState = cold, (boiling), recently_boiled
	// at the start of the game, this kettle is switched on. Edgy, huh?

...and if the notation for that looks a bit redundant, there's a reason for that coming up in a few subsections time.



## 2) Reusing Lists

The above example is fine for the kettle, but what if we have a pot on the stove as well? We can then define a list of states, but put them into variables - and as many variables as we want.

	LIST daysOfTheWeek = Monday, Tuesday, Wednesday, Thursday, Friday
	VAR today = Monday
	VAR tomorrow = Tuesday

### States can be used repeatedly

This allows us to use the same state machine in multiple places.

	LIST heatedWaterStates = cold, boiling, recently_boiled
	VAR kettleState = cold
	VAR potState = cold

	*	{kettleState == cold} [Turn on kettle]
		The kettle begins to boil and bubble.
		~ kettleState = boiling
	*	{potState == cold} [Light stove]
	 	The water in the pot begins to boil and bubble.
	 	~ potState = boiling

But what if we add a microwave as well? We might want start generalising our functionality a bit:

	LIST heatedWaterStates = cold, boiling, recently_boiled
	VAR kettleState = cold
	VAR potState = cold
	VAR microwaveState = cold

	=== function boilSomething(ref thingToBoil, nameOfThing)
		The {nameOfThing} begins to heat up.
		~ thingToBoil = boiling

	=== do_cooking
	*	{kettleState == cold} [Turn on kettle]
		{boilSomething(kettleState, "kettle")}
	*	{potState == cold} [Light stove]
		{boilSomething(potState, "pot")}		*	{microwaveState == cold} [Turn on microwave]
		{boilSomething(microwaveState, "microwave")}

or even...

	LIST heatedWaterStates = cold, boiling, recently_boiled
	VAR kettleState = cold
	VAR potState = cold
	VAR microwaveState = cold

	=== cook_with(nameOfThing, ref thingToBoil)
	+ 	{thingToBoil == cold} [Turn on {nameOfThing}]
	  	The {nameOfThing} begins to heat up.
		~ thingToBoil = boiling
		-> do_cooking.всё

	=== do_cooking
	<- cook_with("kettle", kettleState)
	<- cook_with("pot", potState)
	<- cook_with("microwave", microwaveState)
	- (всё)

Note that the "heatedWaterStates" list is still available as well, and can still be tested, and take a value.

#### List values can share names

Reusing lists brings with it ambiguity. If we have:

	LIST colours = red, green, blue, purple
	LIST moods = mad, happy, blue

	VAR status = blue

... how can the compiler know which blue you meant?

We resolve these using a `.` syntax similar to that used for knots and stitches.

	VAR status = colours.blue

...and the compiler will issue an error until you specify.

Note the "family name" of the state, and the variable containing a state, are totally separate. So

	{ statesOfGrace == statesOfGrace.fallen:
		// is the current state "fallen"
	}

... is correct.


#### Дополнительно: a LIST is actually a variable

One surprising feature is the statement

	LIST statesOfGrace = ambiguous, saintly, fallen

actually does two things simultaneously: it creates three values, `ambiguous`, `saintly` and `fallen`, and gives them the name-parent `statesOfGrace` if needed; and it creates a variable called `statesOfGrace`.

And that variable can be used like a normal variable. So the following is valid, if horribly confusing and a bad idea:

	LIST statesOfGrace = ambiguous, saintly, fallen

	~ statesOfGrace = 3.1415 // set the variable to a number not a list value

...and it wouldn't preclude the following from being fine:

	~ temp anotherStateOfGrace = statesOfGrace.saintly




## 3) List Values

When a list is defined, the values are listed in an order, and that order is considered to be significant. In fact, we can treat these values as if they *were* numbers. (That is to say, they are enums.)

	LIST volumeLevel = off, quiet, medium, loud, deafening
	VAR lecturersVolume = quiet
	VAR murmurersVolume = quiet

	{ lecturersVolume < deafening:
		~ lecturersVolume++

		{ lecturersVolume > murmurersVolume:
			~ murmurersVolume++
			The murmuring gets louder.
		}
	}

The values themselves can be printed using the usual `{...}` syntax, but this will print their name.

	The lecturer's voice becomes {lecturersVolume}.

### Converting values to numbers

The numerical value, if needed, can be got explicitly using the LIST_VALUE function. Note the first value in a list has the value 1, and not the value 0.

	The lecturer has {LIST_VALUE(deafening) - LIST_VALUE(lecturersVolume)} notches still available to him.

### Converting numbers to values

You can go the other way by using the list's name as a function:

	LIST Numbers = one, two, three
	VAR score = one
	~ score = Numbers(2) // score will be "two"

### Дополнительно: defining your own numerical values

By default, the values in a list start at 1 and go up by one each time, but you can specify your own values if you need to.

	LIST primeNumbers = two = 2, three = 3, five = 5

If you specify a value, but not the next value, ink will assume an increment of 1. So the following is the same:

	LIST primeNumbers = two = 2, three, five = 5


## 4) Multivalued Lists

The following examples have all included one deliberate untruth, which we'll now remove. Lists - and variables containing list values - do not have to contain only one value.

### Lists are boolean sets  

A list variable is not a variable containing a number. Rather, a list is like the in/out nameboard in an accommodation block. It contains a list of names, each of which has a room-number associated with it, and a slider to say "in" or "out".

Maybe no one is in:

	LIST DoctorsInSurgery = Adams, Bernard, Cartwright, Denver, Eamonn

Maybe everyone is:

	LIST DoctorsInSurgery = (Adams), (Bernard), (Cartwright), (Denver), (Eamonn)

Or maybe some are and some aren't:

	LIST DoctorsInSurgery = (Adams), Bernard, (Cartwright), Denver, Eamonn

Names in brackets are included in the initial state of the list.

Note that if you're defining your own values, you can place the brackets around the whole term or just the name:

	LIST primeNumbers = (two = 2), (three) = 3, (five = 5)

#### Assiging multiple values

We can assign all the values of the list at once as follows:

	~ DoctorsInSurgery = (Adams, Bernard)
	~ DoctorsInSurgery = (Adams, Bernard, Eamonn)

We can assign the empty list to clear a list out:

	~ DoctorsInSurgery = ()


#### Adding and removing entries

List entries can be added and removed, singly or collectively.

	~ DoctorsInSurgery = DoctorsInSurgery + Adams 	~ DoctorsInSurgery += Adams  // this is the same as the above
	~ DoctorsInSurgery -= Eamonn
	~ DoctorsInSurgery += (Eamonn, Denver)
	~ DoctorsInSurgery -= (Adams, Eamonn, Denver)

Trying to add an entry that's already in the list does nothing. Trying to remove an entry that's not there also does nothing. Neither produces an error, and a list can never contain duplicate entries.


### Basic Queries

We have a few basic ways of getting information about what's in a list:

	LIST DoctorsInSurgery = (Adams), Bernard, (Cartwright), Denver, Eamonn

	{LIST_COUNT(DoctorsInSurgery)} 	//  "2"
	{LIST_MIN(DoctorsInSurgery)} 		//  "Adams"
	{LIST_MAX(DoctorsInSurgery)} 		//  "Cartwright"

#### Testing for emptiness

Like most values in ink, a list can be tested "as it is", and will return true, unless it's empty.

	{ DoctorsInSurgery: The surgery is open today. | Everyone has gone home. }

#### Testing for exact equality

Testing multi-valued lists is slightly more complex than single-valued ones. Equality (`==`) now means 'set equality' - that is, all entries are identical.

So one might say:

	{ DoctorsInSurgery == (Adams, Bernard):
		Dr Adams and Dr Bernard are having a loud argument in one corner.
	}

If Dr Eamonn is in as well, the two won't argue, as the lists being compared won't be equal - DoctorsInSurgery will have an Eamonn that the list (Adams, Bernard) doesn't have.

Not equals works as expected:

	{ DoctorsInSurgery != (Adams, Bernard):
		At least Adams and Bernard aren't arguing.
	}

#### Testing for containment

What if we just want to simply ask if Adams and Bernard are present? For that we use a new operator, `has`, otherwise known as `?`.

	{ DoctorsInSurgery ? (Adams, Bernard):
		Dr Adams and Dr Bernard are having a hushed argument in one corner.
	}

And `?` can apply to single values too:

	{ DoctorsInSurgery has Eamonn:
		Dr Eamonn is polishing his glasses.
	}

We can also negate it, with `hasnt` or `!?` (not `?`). Note this starts to get a little complicated as

	DoctorsInSurgery !? (Adams, Bernard)

does not mean neither Adams nor Bernard is present, only that they are not *both* present (and arguing).


#### Пример: basic knowledge tracking

The simplest use of a multi-valued list is for tracking "game flags" tidily.

	LIST Facts = (Fogg_is_fairly_odd), 	first_name_phileas, (Fogg_is_English)

	{Facts ? Fogg_is_fairly_odd:I smiled politely.|I frowned. Was he a lunatic?}
	'{Facts ? first_name_phileas:Phileas|Monsieur}, really!' I cried.

In particular, it allows us to test for multiple game flags in a single line.

	{ Facts ? (Fogg_is_English, Fogg_is_fairly_odd):  
		<> 'I know Englishmen are strange, but this is *incredible*!'
	}


#### Пример: a doctor's surgery

We're overdue a fuller example, so here's one.

	LIST DoctorsInSurgery = (Adams), Bernard, Cartwright, (Denver), Eamonn

	-> waiting_room

	=== function whos_in_today()
		In the surgery today are {DoctorsInSurgery}.

	=== function doctorEnters(who)
		{ DoctorsInSurgery !? who:
			~ DoctorsInSurgery += who
			Dr {who} arrives in a fluster.
		}

	=== function doctorLeaves(who)
		{ DoctorsInSurgery ? who:
			~ DoctorsInSurgery -= who
			Dr {who} leaves for lunch.
		}

	=== waiting_room
		{whos_in_today()}
		*	[Time passes...]
			{doctorLeaves(Adams)} {doctorEnters(Cartwright)} {doctorEnters(Eamonn)}
			{whos_in_today()}

This produces:

	In the surgery today are Adams, Denver.

	> Time passes...

	Dr Adams leaves for lunch. Dr Cartwright arrives in a fluster. Dr Eamonn arrives in a fluster.

	In the surgery today are Cartwright, Denver, Eamonn.

#### Дополнительно: nicer list printing

The basic list print is not especially attractive for use in-game. The following is better:

	=== function listWithCommas(list, if_empty)
	    {LIST_COUNT(list):
	    - 2:
	        	{LIST_MIN(list)} and {listWithCommas(list - LIST_MIN(list), if_empty)}
	    - 1:
	        	{list}
	    - 0:
				{if_empty}	        
	    - else:
	      		{LIST_MIN(list)}, {listWithCommas(list - LIST_MIN(list), if_empty)}
	    }

	LIST favouriteDinosaurs = (stegosaurs), brachiosaur, (anklyosaurus), (pleiosaur)

	My favourite dinosaurs are {listWithCommas(favouriteDinosaurs, "all extinct")}.

It's probably also useful to have an is/are function to hand:

	=== function isAre(list)
		{LIST_COUNT(list) == 1:is|are}

	My favourite dinosaurs {isAre(favouriteDinosaurs)} {listWithCommas(favouriteDinosaurs, "all extinct")}.

And to be pendantic:

	My favourite dinosaur{LIST_COUNT(favouriteDinosaurs) != 1:s} {isAre(favouriteDinosaurs)} {listWithCommas(favouriteDinosaurs, "all extinct")}.


#### Lists don't need to have multiple entries

Lists don't *have* to contain multiple values. If you want to use a list as a state-machine, the examples above will all work - set values using `=`, `++` and `--`; test them using `==`, `<`, `<=`, `>` and `>=`. These will all work as expected.

### The "full" list

Note that `LIST_COUNT`, `LIST_MIN` and `LIST_MAX` are refering to who's in/out of the list, not the full set of *possible* doctors. We can access that using

	LIST_ALL(element of list)

or

	LIST_ALL(list containing elements of a list)

	{LIST_ALL(DoctorsInSurgery)} // Adams, Bernard, Cartwright, Denver, Eamonn
	{LIST_COUNT(LIST_ALL(DoctorsInSurgery))} // "5"
	{LIST_MIN(LIST_ALL(Eamonn))} 				// "Adams"

Note that printing a list using `{...}` produces a bare-bones representation of the list; the values as words, delimited by commas.

#### Дополнительно: "refreshing" a list's type

If you really need to, you can make an empty list that knows what type of list it is.

	LIST ValueList = first_value, second_value, third_value
	VAR myList = ()

	~ myList = ValueList()

You'll then be able to do:

	{ LIST_ALL(myList) }

#### Дополнительно: a portion of the "full" list

You can also retrieve just a "slice" of the full list, using the `LIST_RANGE` function.

	LIST_RANGE(list_name, min_value, max_value)

### Пример: Tower of Hanoi

To demonstrate a few of these ideas, here's a functional Tower of Hanoi example, written so no one else has to write it.


	LIST Discs = one, two, three, four, five, six, seven
	VAR post1 = ()
	VAR post2 = ()
	VAR post3 = ()

	~ post1 = LIST_ALL(Discs)

	-> gameloop

	=== function can_move(from_list, to_list) ===
	    {
	    -   LIST_COUNT(from_list) == 0:
	        // no discs to move
	        ~ return false
	    -   LIST_COUNT(to_list) > 0 && LIST_MIN(from_list) > LIST_MIN(to_list):
	        // the moving disc is bigger than the smallest of the discs on the new tower
	        ~ return false
	    -   else:  
	    	 // nothing stands in your way!
	        ~ return true

	    }

	=== function move_ring( ref from, ref to ) ===
	    ~ temp whichRingToMove = LIST_MIN(from)
	    ~ from -= whichRingToMove
	    ~ to += whichRingToMove

	== function getListForTower(towerNum)
	    { towerNum:
	        - 1:    ~ return post1
	        - 2:    ~ return post2
	        - 3:    ~ return post3
	    }

	=== function name(postNum)
	    the {postToPlace(postNum)} temple

	=== function Name(postNum)
	    The {postToPlace(postNum)} temple

	=== function postToPlace(postNum)
	    { postNum:
	        - 1: first
	        - 2: second
	        - 3: third
	    }

	=== function describe_pillar(listNum) ==
	    ~ temp list = getListForTower(listNum)
	    {
	    - LIST_COUNT(list) == 0:
	        {Name(listNum)} is empty.
	    - LIST_COUNT(list) == 1:
	        The {list} ring lies on {name(listNum)}.
	    - else:
	        On {name(listNum)}, are the discs numbered {list}.
	    }


	=== gameloop
	    Staring down from the heavens you see your followers finishing construction of the last of the great temples, ready to begin the work.
	- (верх)
	    +  (describe) {true || TURNS_SINCE(-> describe) >= 2 || !describe} [ Regard the temples]
	        You regard each of the temples in turn. On each is stacked the rings of stone. {describe_pillar(1)} {describe_pillar(2)} {describe_pillar(3)}
	    <- move_post(1, 2, post1, post2)   
	    <- move_post(2, 1, post2, post1)  
	    <- move_post(1, 3, post1, post3)  
	    <- move_post(3, 1, post3, post1)  
	    <- move_post(3, 2, post3, post2)  
	    <- move_post(2, 3, post2, post3)  
	    -> DONE

	= move_post(from_post_num, to_post_num, ref from_post_list, ref to_post_list)
	    +   { can_move(from_post_list, to_post_list) }
	        [ Move a ring from {name(from_post_num)} to {name(to_post_num)} ]
	        { move_ring(from_post_list, to_post_list) }
	        { stopping:
	        -   The priests far below construct a great harness, and after many years of work, the great stone ring is lifted up into the air, and swung over to the next of the temples.
	            The ropes are slashed, and in the blink of an eye it falls once more.
	        -   Your next decree is met with a great feast and many sacrifices. After the funeary smoke has cleared, work to shift the great stone ring begins in earnest. A generation grows and falls, and the ring falls into its ordained place.
	        -   {cycle:
	            - Years pass as the ring is slowly moved.
	            - The priests below fight a war over what colour robes to wear, but while they fall and die, the work is still completed.
	            }
	        }
	    -> верх



## 5) Advanced List Operations

The above section covers basic comparisons. There are a few more powerful features as well, but - as anyone familiar with mathematical   sets will know - things begin to get a bit fiddly. So this section comes with an 'advanced' warning.

A lot of the features in this section won't be necessary for most games.

### Comparing lists

We can compare lists less than exactly using `>`, `<`, `>=` and `<=`. Be warned! The definitions we use are not exactly standard fare. They are based on comparing the numerical value of the elements in the lists being tested.

#### "Distinctly bigger than"

`LIST_A > LIST_B` means "the smallest value in A is bigger than the largest values in B": in other words, if put on a number line, the entirety of A is to the right of the entirety of B. `<` does the same in reverse.

#### "Definitely never smaller than"

`LIST_A >= LIST_B` means - take a deep breath now - "the smallest value in A is at least the smallest value in B, and the largest value in A is at least the largest value in B". That is, if drawn on a number line, the entirety of A is either above B or overlaps with it, but B does not extend higher than A.

Note that `LIST_A > LIST_B` implies `LIST_A != LIST_B`, and `LIST_A >= LIST_B` allows `LIST_A == LIST_B` but precludes `LIST_A < LIST_B`, as you might hope.

#### Health warning!

`LIST_A >= LIST_B` is *not* the same as `LIST_A > LIST_B or LIST_A == LIST_B`.

The moral is, don't use these unless you have a clear picture in your mind.

### Inverting lists

A list can be "inverted", which is the equivalent of going through the accommodation in/out name-board and flipping every switch to the opposite of what it was before.

	LIST GuardsOnDuty = (Smith), (Jones), Carter, Braithwaite

	=== function changingOfTheGuard
		~ GuardsOnDuty = LIST_INVERT(GuardsOnDuty)


Note that `LIST_INVERT` on an empty list will return a null value, if the game doesn't have enough context to know what invert. If you need to handle that case, it's safest to do it by hand:

	=== function changingOfTheGuard
		{!GuardsOnDuty: // "is GuardsOnDuty empty right now?"
			~ GuardsOnDuty = LIST_ALL(Smith)
		- else:
			~ GuardsOnDuty = LIST_INVERT(GuardsOnDuty)
		}

#### Footnote

The syntax for inversion was originally `~ list` but we changed it because otherwise the line

	~ list = ~ list

was not only functional, but actually caused list to invert itself, which seemed excessively perverse.

### Intersecting lists

The `has` or `?` operator is, somewhat more formally, the "are you a subset of me" operator, ⊇, which includes the sets being equal, but which doesn't include if the larger set doesn't entirely contain the smaller set. 

To test for "some overlap" between lists, we use the overlap operator, `^`, to get the *intersection*.

	LIST CoreValues = strength, courage, compassion, greed, nepotism, self_belief, delusions_of_godhood
	VAR desiredValues = (strength, courage, compassion, self_belief )
	VAR actualValues =  ( greed, nepotism, self_belief, delusions_of_godhood )

	{desiredValues ^ actualValues} // prints "self_belief"  

The result is a new list, so you can test it:

	{desiredValues ^ actualValues: The new president has at least one desirable quality.}

	{LIST_COUNT(desiredValues ^ actualValues) == 1: Correction, the new president has only one desirable quality. {desiredValues ^ actualValues == self_belief: It's the scary one.}}




## 6) Multi-list Lists


So far, all of our examples have included one large simplification, again - that the values in a list variable have to all be from the same list family. But they don't.

This allows us to use lists - which have so far played the role of state-machines and flag-trackers - to also act as general properties, which is useful for world modelling.

This is our inception moment. The results are powerful, but also more like "real code" than anything that's come before.

### Lists to track objects

For instance, we might define:

	LIST Characters = Alfred, Batman, Robin
	LIST Props = champagne_glass, newspaper

	VAR BallroomContents = (Alfred, Batman, newspaper)
	VAR HallwayContents = (Robin, champagne_glass)

We could then describe the contents of any room by testing its state:

	=== function describe_room(roomState)
		{ roomState ? Alfred: Alfred is here, standing quietly in a corner. } { roomState ? Batman: Batman's presence dominates all. } { roomState ? Robin: Robin is all but forgotten. }
		<> { roomState ? champagne_glass: A champagne glass lies discarded on the floor. } { roomState ? newspaper: On one table, a headline blares out WHO IS THE BATMAN? AND *WHO* IS HIS BARELY-REMEMBERED ASSISTANT? }

So then:

	{ describe_room(BallroomContents) }

produces:

	Alfred is here, standing quietly in a corner. Batman's presence dominates all.

	On one table, a headline blares out WHO IS THE BATMAN? AND *WHO* IS HIS BARELY-REMEMBERED ASSISTANT?

While:

	{ describe_room(HallwayContents) }

gives:

	Robin is all but forgotten.

	A champagne glass lies discarded on the floor.

And we could have options based on combinations of things:

	*	{ currentRoomState ? (Batman, Alfred) } [Talk to Alfred and Batman]
		'Say, do you two know each other?'

### Lists to track multiple states

We can model devices with multiple states. Back to the kettle again...

	LIST OnOff = on, off
	LIST HotCold = cold, warm, hot

	VAR kettleState = off, cold

	=== function turnOnKettle() ===
	{ kettleState ? hot:
		You turn on the kettle, but it immediately flips off again.
	- else:
		The water in the kettle begins to heat up.
		~ kettleState -= off
		~ kettleState += on
		// note we avoid "=" as it'll remove all existing states
	}

	=== function can_make_tea() ===
		~ return kettleState ? (hot, off)

These mixed states can make changing state a bit trickier, as the off/on above demonstrates, so the following helper function can be useful.

 	=== function changeStateTo(ref stateVariable, stateToReach)
 		// remove all states of this type
 		~ stateVariable -= LIST_ALL(stateToReach)
 		// put back the state we want
 		~ stateVariable += stateToReach

 which enables code like:

 	~ changeState(kettleState, on)
 	~ changeState(kettleState, warm)


#### How does this affect queries?

The queries given above mostly generalise nicely to multi-valued lists

    LIST Letters = a,b,c
    LIST Numbers = one, two, three

    VAR mixedList = (a, three, c)

	{LIST_ALL(mixedList)}   // a, one, b, two, c, three
    {LIST_COUNT(mixedList)} // 3
    {LIST_MIN(mixedList)}   // a
    {LIST_MAX(mixedList)}   // three or c, albeit unpredictably

    {mixedList ? (a,b) }        // false
    {mixedList ^ LIST_ALL(a)}   // a, c

    { mixedList >= (one, a) }   // true
    { mixedList < (three) }     // false

	{ LIST_INVERT(mixedList) }            // one, b, two


## 7) Long example: crime scene

Finally, here's a long example, demonstrating a lot of ideas from this section in action. You might want to try playing it before reading through to better understand the various moving parts.

	-> murder_scene

	//
	// 	System: items can have various states
	//	Some are general, some specific to particular items
	//

	LIST OffOn = off, on
	LIST SeenUnseen = unseen, seen

	LIST GlassState = (none), steamed, steam_gone
	LIST BedState = (made_up), covers_shifted, covers_off, stain_visible

	//
	// System: inventory
	//

	LIST Inventory = (none), cane, knife

	=== function get(x)
	    ~ Inventory += x

	//
	// System: positioning things
	// Items can be put in and on places
	//

	LIST Supporters = on_desk, on_floor, on_bed, under_bed, held, with_joe

	=== function move_to_supporter(ref item_state, new_supporter) ===
	    ~ item_state -= LIST_ALL(Supporters)
	    ~ item_state += new_supporter

	//
	// System: Incremental knowledge.
	// Each list is a chains of facts. Each fact supercedes the fact before it.
	//


	LIST BedKnowledge = (none), neatly_made, crumpled_duvet, hastily_remade, body_on_bed, murdered_in_bed, murdered_while_asleep
	LIST KnifeKnowledge = (none), prints_on_knife, joe_seen_prints_on_knife,joe_wants_better_prints, joe_got_better_prints
	LIST WindowKnowledge = (none), steam_on_glass, fingerprints_on_glass, fingerprints_on_glass_match_knife

	VAR knowledgeState = ()

	=== function learn(x) ===
		// learn this fact
	    ~ knowledgeState += x

	=== function learnt(x) ===
		// have you learnt this fact, or indeed a stronger one
	    ~ return highest_state_for_set_of_state(x) >= x

	=== function between(x, y) ===
		// are you between two ideas? Not necessarily in the same knowledge tree.
	    ~ return learnt(x) && not learnt(y)

	=== function think(x) ===
		// is this your current "strongest" idea in this knowledge set?
	    ~ return highest_state_for_set_of_state(x) == x

	=== function highest_state_for_set_of_state(x) ===
	    ~ return LIST_MAX(knowledgeState ^ LIST_ALL(x))

	=== function did_learn(x) ===
		//	did you learn this particular fact?
	    ~ return knowledgeState ? x

	//
	// Set up the scene
	//

	VAR bedroomLightState = (off, on_desk)
	VAR knifeState = (under_bed)

	//
	// Content
	//

	=== murder_scene ===
	    The bedroom. This is where it happened. Now to look for clues.
	- (верх)
	    { bedroomLightState ? seen:     <- seen_light  }
	    <- compare_prints(-> верх)

	    *   (dobed) [The bed...]
	        The bed was low to the ground, but not so low something might not roll underneath. It was still neatly made.
	        ~ learn(neatly_made)
	        - - (bedhub)
	        * *     [Lift the bedcover]
	                I lifted back the bedcover. The duvet underneath was crumpled.
	                ~ learn(crumpled_duvet)
	                ~ BedState = covers_shifted
	        * *     (uncover) {learnt(crumpled_duvet)}
	                [Remove the cover]
	                Careful not to disturb anything beneath, I removed the cover entirely. The duvet below was rumpled.
	                Not the work of the maid, who was conscientious to a point. Clearly this had been thrown on in a hurry.
	                ~ learn(hastily_remade)
	                ~ BedState = covers_off
	        * *     (duvet) {BedState == covers_off} [ Pull back the duvet ]
	                I pulled back the duvet. Beneath it was a sheet, sticky with blood.
	                ~ BedState = stain_visible
	                ~ learn(body_on_bed)
	                Either the body had been moved here before being dragged to the floor - or this is was where the murder had taken place.
	        * *     {!(BedState ? made_up)} [ Remake the bed ]
	                Carefully, I pulled the bedsheets back into place, trying to make it seem undisturbed.
	                ~ BedState = made_up
	        * *     [Test the bed]
	                I pushed the bed with spread fingers. It creaked a little, but not so much as to be obnoxious.
	        * *     (darkunder) [Look under the bed]
	                Lying down, I peered under the bed, but could make nothing out.

	        * *     {TURNS_SINCE(-> dobed) > 1} [Something else?]
	                I took a step back from the bed and looked around.
	                -> верх
	        - -     -> bedhub

	    *   {darkunder && bedroomLightState ? on_floor && bedroomLightState ? on}
	        [ Look under the bed ]
	        I peered under the bed. Something glinted back at me.
	        - - (reaching)
	        * *     [ Reach for it ]
	                I fished with one arm under the bed, but whatever it was, it had been kicked far enough back that I couldn't get my fingers on it.
	                -> reaching
	        * *     {Inventory ? cane} [Knock it with the cane]
	                -> knock_with_cane

	        * *     {reaching > 1 } [ Stand up ]
	                I stood up once more, and brushed my coat down.
	                -> верх

	    *   (knock_with_cane) {reaching && TURNS_SINCE(-> reaching) >= 4 &&  Inventory ? cane } [Use the cane to reach under the bed ]
	        Positioning the cane above the carpet, I gave the glinting thing a sharp tap. It slid out from the under the foot of the bed.
	        ~ move_to_supporter( knifeState, on_floor )
	        * *     (standup) [Stand up]
	                Satisfied, I stood up, and saw I had knocked free a bloodied knife.
	                -> верх
	        * *     [Look under the bed once more]
	                Moving the cane aside, I looked under the bed once more, but there was nothing more there.
	                -> standup        

	    *   {knifeState ? on_floor} [Pick up the knife]
	        Careful not to touch the handle, I lifted the blade from the carpet.
	        ~ get(knife)

	    *   {Inventory ? knife} [Look at the knife]
	        The blood was dry enough. Dry enough to show up partial prints on the hilt!
	        ~ learn(prints_on_knife)

	    *   [   The desk... ]
	        I turned my attention to the desk. A lamp sat in one corner, a neat, empty in-tray in the other. There was nothing else out.
	        Leaning against the desk was a wooden cane.
	        ~ bedroomLightState += seen
	        - - (deskstate)
	        * *     (pickup_cane) {Inventory !? cane}    [Pick up the cane ]
	                ~ get(cane)
	                I picked up the wooden cane. It was heavy, and unmarked.

	        * *    { bedroomLightState !? on } [Turn on the lamp]
	                -> operate_lamp ->
	        * *     [Look at the in-tray ]
	                I regarded the in-tray, but there was nothing to be seen. Either the victim's papers were taken, or his line of work had seriously dried up. Or the in-tray was all for show.
	        + +     (open)  {open < 3} [Open a drawer]
	                I tried {a drawer at random|another drawer|a third drawer}. {Locked|Also locked|Unsurprisingly, locked as well}.

	        * *     {deskstate >= 2} [Something else?]
	                I took a step away from the desk once more.
	                -> верх
	        - -     -> deskstate

	    *     {(Inventory ? cane) && TURNS_SINCE(-> deskstate) <= 2} [Swoosh the cane]    
	        I was still holding the cane: I gave it an experimental swoosh. It was heavy indeed, though not heavy enough to be used as a bludgeon.
	        But it might have been useful in self-defence. Why hadn't the victim reached for it? Knocked it over?

	    *   [The window...]
	        I went over to the window and peered out. A dismal view of the little brook that ran down beside the house.
	        - - (window_opts)
	        <- compare_prints(-> window_opts)
	        * *     (downy) [Look down at the brook]
	                { GlassState ? steamed:
	                    Through the steamed glass I couldn't see the brook. -> see_prints_on_glass -> window_opts
	                }
	                I watched the little stream rush past for a while. The house probably had damp but otherwise, it told me nothing.
	        * *     (greasy) [Look at the glass]
	                { GlassState ? steamed: -> downy }
	                The glass in the window was greasy. No one had cleaned it in a while, inside or out.
	        * *     { GlassState ? steamed && not see_prints_on_glass && downy && greasy }
	                [ Look at the steam ]
	                A cold day outside. Natural my breath should steam. -> see_prints_on_glass ->
	        + +     {GlassState ? steam_gone} [ Breathe on the glass ]
	                I breathed gently on the glass once more. {learnt(fingerprints_on_glass): The fingerprints reappeared. }
	                ~ GlassState = steamed

	        + +     [Something else?]
	                { window_opts < 2 || learnt(fingerprints_on_glass) || GlassState ? steamed:
	                    I looked away from the dreary glass.
	                    {GlassState ? steamed:
	                        ~ GlassState = steam_gone
	                        <> The steam from my breath faded.
	                    }
	                    -> верх
	                }
	                I leant back from the glass. My breath had steamed up the pane a little.
	               ~ GlassState = steamed
	        - -     -> window_opts



	    *   {верх >= 5} [Leave the room]
	        I'd seen enough. I {bedroomLightState ? on:switched off the lamp, then} turned and left the room.
	        -> joe_in_hall
	    -   -> верх

	= see_prints_on_glass
	    ~ learn(fingerprints_on_glass)
	    {But I could see a few fingerprints, as though someone had leant their palm against it.|The fingerprints were quite clear and well-formed.} They faded as I watched.   
	    ~ GlassState = steam_gone
	    ->->

	= compare_prints (-> backto)
	    *   {learnt(fingerprints_on_glass) && learnt(prints_on_knife) && !learnt(fingerprints_on_glass_match_knife)} [Compare the prints on the knife and the window ]    
	        Holding the bloodied knife near the window, I breathed to bring out the prints once more, and compared them as best I could.
	        Hardly scientific, but they seemed very similar - very similiar indeed.
	        ~ learn(fingerprints_on_glass_match_knife)
	        -> backto

	= operate_lamp
	    I flicked the light switch.
	    { bedroomLightState ? on:
	        <> The bulb fell dark.
	        ~ bedroomLightState += off
	        ~ bedroomLightState -= on
	    - else:
	        { bedroomLightState ? on_floor: <> A little light spilled under the bed.} { bedroomLightState ? on_desk : <> The light gleamed on the polished tabletop. }
	        ~ bedroomLightState -= off
	        ~ bedroomLightState += on
	    }
	    ->->

	= seen_light  
	    *   {!(bedroomLightState ? on)} [ Turn on lamp ]
	        -> operate_lamp ->

	    *   { !(bedroomLightState ? on_bed)  && BedState ? stain_visible }
	        [ Move the light to the bed ]
	        ~ move_to_supporter(bedroomLightState, on_bed)
	        I moved the light over to the bloodstain and peered closely at it. It had soaked deeply into the fibres of the cotton sheet.
	        There was no doubt about it. This was where the blow had been struck.
	        ~ learn(murdered_in_bed)

	    *   { !(bedroomLightState ? on_desk) } {TURNS_SINCE(-> floorit) >= 2 }
	        [ Move the light back to the desk ]
	        ~ move_to_supporter(bedroomLightState, on_desk)
	        I moved the light back to the desk, setting it down where it had originally been.
	    *   (floorit) { !(bedroomLightState ? on_floor) && darkunder }
	        [Move the light to the floor ]
	        ~ move_to_supporter(bedroomLightState, on_floor)
	        I picked the light up and set it down on the floor.
	    -   -> верх

	=== joe_in_hall
	    My police contact, Joe, was waiting in the hall. 'So?' he demanded. 'Did you find anything interesting?'
	- (found)
	    *   {found == 1} 'Nothing.'
	        He shrugged. 'Shame.'
	        -> всё
	    *   { Inventory ? knife } 'I found the murder weapon.'
	        'Good going!' Joe replied with a grin. 'We thought the murderer had gotten rid of it. I'll bag that for you now.'
	        ~ move_to_supporter(knifeState, with_joe)
	    *   {learnt(prints_on_knife)} { knifeState ? with_joe }
	        'There are prints on the blade[.'],' I told him.
	        He regarded them carefully.
	        'Hrm. Not very complete. It'll be hard to get a match from these.'
	        ~ learn(joe_seen_prints_on_knife)
	    *   { learnt(fingerprints_on_glass_match_knife) && learnt(joe_seen_prints_on_knife) }
	        'They match a set of prints on the window, too.'
	        'Anyone could have touched the window,' Joe replied thoughtfully. 'But if they're more complete, they should help us get a decent match!'
	        ~ learn(joe_wants_better_prints)
	    *   { between(body_on_bed, murdered_in_bed)}
	        'The body was moved to the bed at some point[.'],' I told him. 'And then moved back to the floor.'
	        'Why?'
	        * *     'I don't know.'
	                Joe nods. 'All right.'
	        * *     'Perhaps to get something from the floor?'
	                'You wouldn't move a whole body for that.'
	        * *     'Perhaps he was killed in bed.'
	                'It's just speculation at this point,' Joe remarks.
	    *   { learnt(murdered_in_bed) }
	        'The victim was murdered in bed, and then the body was moved to the floor.'
	        'Why?'
	        * *     'I don't know.'
	                Joe nods. 'All right, then.'
	        * *     'Perhaps the murderer wanted to mislead us.'
	                'How so?'
	            * * *   'They wanted us to think the victim was awake[.'], I replied thoughtfully. 'That they were meeting their attacker, rather than being stabbed in their sleep.'
	            * * *   'They wanted us to think there was some kind of struggle[.'],' I replied. 'That the victim wasn't simply stabbed in their sleep.'
	            - - -   'But if they were killed in bed, that's most likely what happened. Stabbed, while sleeping.'
	                    ~ learn(murdered_while_asleep)
	        * *     'Perhaps the murderer hoped to clean up the scene.'
	                'But they were disturbed? It's possible.'


	    *   { found > 1} 'That's it.'
	        'All right. It's a start,' Joe replied.
	        -> всё
	    -   -> found
	-   (всё)
	    {
	    - between(joe_wants_better_prints, joe_got_better_prints):
	        ~ learn(joe_got_better_prints)
	        <>  He moved for the door.  'I'll get those prints from the window now.'
	    - learnt(joe_seen_prints_on_knife):
	        <> 'I'll run those prints as best I can.'
	    - else:
	        <> 'Not much to go on.'
	    }
	    -> END

## 8) Summary

To summarise a difficult section, **ink**'s list construction provides:

### Flags
* 	Each list entry is an event
* 	Use `+=` to mark an event as having occurred
*  	Test using `?` and `!?`

Пример:

	LIST GameEvents = foundSword, openedCasket, metGorgon
	{ GameEvents ? openedCasket }
	{ GameEvents ? (foundSword, metGorgon) }
	~ GameEvents += metGorgon

### State machines
* 	Each list entry is a state
*  Use `=` to set the state; `++` and `--` to step forward or backward
*  Test using `==`, `>` etc

Пример:

	LIST PancakeState = ingredients_gathered, batter_mix, pan_hot, pancakes_tossed, ready_to_eat
	{ PancakeState == batter_mix }
	{ PancakeState < ready_to_eat }
	~ PancakeState++

### Properties
*	Each list is a different property, with values for the states that property can take (on or off, lit or unlit, etc)
* 	Change state by removing the old state, then adding in the new
*  Test using `?` and `!?`

Пример:

	LIST OnOffState = on, off
	LIST ChargeState = uncharged, charging, charged

	VAR PhoneState = (off, uncharged)

	*	{PhoneState !? uncharged } [Plug in phone]
		~ PhoneState -= LIST_ALL(ChargeState)
		~ PhoneState += charging
		You plug the phone into charge.
	*	{ PhoneState ? (on, charged) } [ Call my mother ]




# Part 6: International character support in identifiers

By default, ink has no limitations on the use of non-ASCII characters inside the story content. However, a limitation currently exsits
on the characters that can be used for names of constants, variables, stictches, diverts and other named flow elements (a.k.a. *identifiers*).

Sometimes it is inconvenient for a writer using a non-ASCII language to write a story because they have to constantly switch to naming identifiers in ASCII and then switching back to whatever language they are using for the story. In addition, naming identifiers in the author's own language could improve the overal readibility of the raw story format.

In an effort to assist in the above scenario, ink *automatically* supports a list of pre-defined non-ASCII character ranges that can be used as identifiers. In general, those ranges have been selected to include the alpha-numeric subset of the official unicode character range, which would suffice for naming identifiers. The below section gives more detailed information on the non-ASCII characters that ink automatically supports.

### Supported Identifier Characters

The support for the additional character ranges in ink is currently limited to a predefined set of character ranges.

Below is a listing of the currently supported identifier ranges.

 - **Arabic**

   Enables characters for languages of the Arabic family and is a subset of the official *Arabic* unicode range `\u0600`-`\u06FF`.


 - **Armenian**

   Enables characters for the Armenian language and is a subset of the official *Armenian* unicode range `\u0530`-`\u058F`.


 - **Cyrillic**

   Enables characters for languages using the Cyrillic alphabet and is a subset of the official *Cyrillic* unicode range `\u0400`-`\u04FF`.


 - **Greek**  

   Enables characters for languages using the Greek alphabet and is a subset of the official *Greek and Coptic* unicode range `\u0370`-`\u03FF`.


 - **Hebrew**  

   Enables characters in Hebrew using the Hebrew alphabet and is a subset of the official *Hebrew* unicode range `\u0590`-`\u05FF`.


 - **Latin Extended A**  

   Enables an extended character range subset of the Latin alphabet - completely represented by the official *Latin Extended-A* unicode range `\u0100`-`\u017F`.


 - **Latin Extended B**

   Enables an extended character range subset of the Latin alphabet - completely represented by the official *Latin Extended-B* unicode range `\u0180`-`\u024F`.  


**NOTE!** ink files should be saved in UTF-8 format, which ensures that the above character ranges are supported.

If a particular character range that you would like to use within identifiers isn't supported, feel free to open an [issue](https://github.com/inkle/ink/issues/new) or [pull request](https://github.com/inkle/ink/pulls) on the main ink repo.
